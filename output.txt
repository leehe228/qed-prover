"""main.rs"""
```rust
#![feature(slice_as_chunks)]
#![feature(if_let_guard)]
#![feature(let_chains)]
use std::any::Any;
use std::collections::BTreeMap;
use std::fs::File;
use std::io;
use std::io::{BufReader, Read, Write};
use std::os::unix::fs::MetadataExt;
use std::path::Path;
use std::time::Instant;

use env_logger::{Builder, Env, Target};
use itertools::Itertools;
use walkdir::WalkDir;

use crate::pipeline::{unify, Input, Stats};

mod pipeline;

fn visit<P: AsRef<Path>>(dir: P, mut cb: impl FnMut(usize, &Path)) -> io::Result<()> {
	WalkDir::new(dir)
		.into_iter()
		.filter_map(|f| {
			f.ok().filter(|f| f.path().is_file() && f.path().extension() == Some("json".as_ref()))
		})
		.sorted_by_cached_key(|e| e.metadata().unwrap().size())
		.enumerate()
		.for_each(|(i, e)| cb(i, e.path()));
	Ok(())
}

#[derive(Debug)]
enum CosetteResult {
	Provable(Stats),
	NotProvable(Stats),
	ParseErr(serde_json::Error),
	Panic(Box<dyn Any + Send>),
}

fn main() -> io::Result<()> {
	Builder::from_env(Env::default().default_filter_or("off"))
		.format(|buf, record| writeln!(buf, "{}", record.args()))
		.target(Target::Stdout)
		.init();
	let mut stats = BTreeMap::new();
	for arg in std::env::args() {
		visit(arg, |i, path| {
			use CosetteResult::*;
			let file = File::open(path).unwrap();
			let mut buf_reader = BufReader::new(file);
			let mut contents = String::new();
			println!("#{}: {}", i, path.to_string_lossy().as_ref());
			let start_time = Instant::now();
			buf_reader.read_to_string(&mut contents).unwrap();
			let result =
				std::panic::catch_unwind(|| match serde_json::from_str::<Input>(&contents) {
					Ok(rel) => {
						let (provable, case_stats) = unify(rel);
						println!(
							"Equivalence is {}provable for {}",
							if provable { "" } else { "not " },
							path.file_name().unwrap().to_str().unwrap(),
						);
						if provable {
							Provable(case_stats)
						} else {
							NotProvable(case_stats)
						}
					},
					Err(e) => {
						log::error!("Not successfully parsed.\n{}", e);
						ParseErr(e)
					},
				});
			let result = match result {
				Ok(res) => res,
				Err(e) => {
					log::error!("{:?}", e);
					Panic(e)
				},
			};
			let result_file = File::create(path.with_extension("result")).unwrap();
			let case_stats = match &result {
				Provable(stats) | NotProvable(stats) => {
					let mut stats = stats.clone();
					stats.provable = matches!(result, Provable(_));
					stats.total_duration = start_time.elapsed();
					stats
				},
				_ => {
					let mut stats = Stats::default();
					stats.panicked = true;
					stats.total_duration = start_time.elapsed();
					stats
				},
			};
			serde_json::to_writer(result_file, &case_stats).unwrap();
			stats.insert(path.to_string_lossy().to_string(), result);
		})?;
	}
	println!("\n\nSTATISTICS");
	let (a, b): (Vec<_>, _) = stats.values().partition(|v| matches!(v, CosetteResult::Provable(_)));
	let (al, bl) = (a.len(), b.len());
	for (name, result) in stats {
		println!("{}\t{:?}", name, result);
	}
	println!("Provable: {} / {}", al, al + bl);
	Ok(())
}
```

"""pipeline.rs"""
```rust
use std::rc::Rc;
use std::time::{Duration, Instant};

use imbl::vector;
use serde::{Deserialize, Serialize};
use z3::{Config, Context, Solver};

use crate::pipeline::normal::Z3Env;
use crate::pipeline::shared::{Ctx, Eval, Schema};
use crate::pipeline::unify::{Unify, UnifyEnv};

pub mod normal;
mod null;
pub mod partial;
pub mod relation;
pub mod shared;
pub mod stable;
pub mod syntax;
#[cfg(test)]
mod tests;
pub mod unify;
pub mod constraint;

#[derive(Serialize, Deserialize)]
pub struct Input {
	schemas: Vec<Schema>,
	pub queries: (relation::Relation, relation::Relation),
	#[serde(default)]
	help: (String, String),
	#[serde(default)]
	pub constraints: Vec<constraint::Constraint>,
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Stats {
	pub provable: bool,
	pub panicked: bool,
	pub complete_fragment: bool,
	pub equiv_class_duration: Duration,
	pub equiv_class_timed_out: bool,
	pub smt_duration: Duration,
	pub smt_timed_out: bool,
	pub nontrivial_perms: bool,
	pub translate_duration: Duration,
	pub normal_duration: Duration,
	pub stable_duration: Duration,
	pub unify_duration: Duration,
	pub total_duration: Duration,
}

pub fn unify(Input { schemas, queries: (rel1, rel2), help , constraints }: Input) -> (bool, Stats) {
	let mut stats = Stats::default();
	let subst = vector![];
	let env = relation::Env(&schemas, &subst, 0);
	log::info!("Schemas:\n{:?}", schemas);
	log::info!("Input:\n{}\n{}", help.0, help.1);
	stats.complete_fragment = rel1.complete() && rel2.complete();
	if rel1 == rel2 {
		println!("Trivially true!");
		return (true, stats);
	}
	let syn_start = Instant::now();
	let rel1 = env.eval(rel1);
	let rel2 = env.eval(rel2);
	stats.translate_duration = syn_start.elapsed();
	log::info!("Syntax left:\n{}", rel1);
	log::info!("Syntax right:\n{}", rel2);
	if rel1 == rel2 {
		return (true, stats);
	}
	let nom_env = &vector![];
	let eval_nom = |rel: syntax::Relation| -> normal::Relation {
		let rel = (&partial::Env::default()).eval(rel);
		nom_env.eval(rel)
	};
	let norm_start = Instant::now();
	let rel1 = eval_nom(rel1);
	let rel2 = eval_nom(rel2);
	stats.normal_duration = norm_start.elapsed();
	log::info!("Normal left:\n{}", rel1);
	log::info!("Normal right:\n{}", rel2);
	if rel1 == rel2 {
		return (true, stats);
	}
	let config = Config::new();
	let z3_ctx = &Context::new(&config);
	let ctx = Rc::new(Ctx::new_with_stats(Solver::new(z3_ctx), stats));
	let z3_env = Z3Env::empty(ctx.clone());
	let eval_stb = |nom: normal::Relation| -> normal::Relation {
		let env = &stable::Env(vector![], z3_env.clone());
		let stb = env.eval(nom);
		nom_env.eval(stb)
	};
	let stb_start = Instant::now();
	let rel1 = eval_stb(rel1);
	let rel2 = eval_stb(rel2);
	ctx.stats.borrow_mut().stable_duration = stb_start.elapsed();
	log::info!("Stable left:\n{}", rel1);
	log::info!("Stable right:\n{}", rel2);
	if rel1 == rel2 {
		return (true, ctx.stats.borrow().clone());
	}
	let phi = (&z3_env).eval(&constraints);
	let env = UnifyEnv(ctx.clone(), vector![], vector![], phi);
	let unify_start = Instant::now();
	let res = env.unify(&rel1, &rel2);
	ctx.stats.borrow_mut().unify_duration = unify_start.elapsed();
	let stats = ctx.stats.borrow().clone();
	(res, stats)
}
```

"""pipeline/null.rs"""
```rust
use std::cell::RefCell;
use std::rc::Rc;

use paste::paste;
use z3::ast::{forall_const, Ast, Bool, Datatype, Dynamic, Int, Real, String};
use z3::{DatatypeAccessor, DatatypeBuilder, DatatypeSort, FuncDecl, Pattern, Solver, Sort};

use super::Stats;

macro_rules! repeat_with {
	($_t:tt $sub:expr) => {
		$sub
	};
}

macro_rules! optional_op {
    ($($env:tt),*; $name:ident ($($v:ident),*)) => {
		optional_op!($($env)*; fix $name $($v)*)
	};
    ($($env:tt),*; $name:ident [$($v:ident),*]) => {
		optional_op!($($env)*; var $name $($v)*)
	};
	($solver:ident $sort:ident $ilsort:ident $olsort:ident; $mode:ident $name:ident $($v:ident)*) => {
		let input_sort = &$ilsort.sort;
		let output_sort = &$olsort.sort;
		let ctx = $solver.get_context();
		let func = FuncDecl::new(
			ctx,
			format!("n-{}-{}", stringify!($ilsort), stringify!($name)),
			&[$(repeat_with!($v input_sort)),*],
			output_sort
		);
		$(let $v = &Datatype::fresh_const(ctx, "v", input_sort) as &dyn Ast;)*
		let vars = &[$($v),*];
		let f_vs = &func.apply(vars);
		let input_none = &$ilsort.variants[0];
		let input_some = &$ilsort.variants[1];
		let output_none = &$olsort.variants[0];
		let output_some = &$olsort.variants[1];
		let body = f_vs._eq(optional_op!(ctx $sort input_none input_some output_none output_some; $mode ($($v)*) ($name $($v)*)));
		let p = Pattern::new(ctx, &[f_vs]);
		let f_def = forall_const(ctx, vars, &[&p], &body);
		$solver.assert(&f_def);
	};
	($ctx:ident $sort:ident $inone:ident $isome:ident $onone:ident $osome:ident; $mode:ident ($v:ident $($tail:ident)*) ($name:ident $($vs:ident)*)) => {
		&$inone.tester.apply(&[$v]).as_bool().unwrap().ite(
			&$onone.constructor.apply(&[]),
			optional_op!($ctx $sort $inone $isome $onone $osome; $mode ($($tail)*) ($name $($vs)*))
		)
	};
	($ctx:ident $sort:ident $inone:ident $isome:ident $onone:ident $osome:ident; fix () ($name:ident $($v:ident)*)) => {
		{
			paste!($(let $v = &$isome.accessors[0].apply(&[$v]).[<as_$sort:snake>]().unwrap();)*);
			&$osome.constructor.apply(&[&$sort::$name($(&$v),*)])
		}
	};
	($ctx:ident $sort:ident $inone:ident $isome:ident $onone:ident $osome:ident; var () ($name:ident $($v:ident)*)) => {
		{
			paste!($(let $v = &$isome.accessors[0].apply(&[$v]).[<as_$sort:snake>]().unwrap();)*);
			&$osome.constructor.apply(&[&$sort::$name($ctx, &[$(&$v),*])])
		}
	}
}

macro_rules! optional_fn {
    ($ilsort:ident $olsort:ident $name:ident ($($v:ident),* $(,)*)) => {
        paste!(
			#[allow(non_snake_case)]
			#[allow(dead_code)]
			pub fn [<$ilsort _ $name>] (&self, $($v: &Dynamic<'c>),*) -> Dynamic<'c> {
            let input_sort = &self.sorts.$ilsort.sort;
			let output_sort = &self.sorts.$olsort.sort;
            let func = FuncDecl::new(
				self.solver.get_context(),
				format!("n-{}-{}", stringify!($ilsort), stringify!($name)),
				&[$(repeat_with!($v input_sort)),*],
				output_sort
			);
            func.apply(&[$($v),*])
        });
    };
    ($ilsort:ident $olsort:ident $name:ident [$($v:ident),* $(,)*]) => {
        optional_fn!($ilsort $olsort $name ($($v),*));
    };
}

pub struct Ctx<'c> {
	pub solver: Solver<'c>,
	pub stats: Rc<RefCell<Stats>>,
	sorts: Sorts<'c>,
}

macro_rules! ctx_impl {
    ($($sort:ident {$($def:ident $args:tt -> $ret:ident);* $(;)*});* $(;)*) => {
        paste!(ctx_impl!($($sort [<$sort:snake>] $($def $args [<$ret:snake>]),*);*););
    };
    ($($sort:ident $lsort:ident $($def:ident $args:tt $olsort:ident),*);*) => {
		struct Sorts<'c> {
			$($lsort: DatatypeSort<'c>),*
		}

        impl<'c> Ctx<'c> {
            pub fn new_with_stats(solver: Solver<'c>, stats: Stats) -> Self {
                let ctx = solver.get_context();
                $(let $lsort = DatatypeBuilder::new(ctx, format!("Option<{}>", stringify!($sort)))
                    .variant(&format!("None{}", stringify!($sort)), vec![])
                    .variant("Some", vec![("val", DatatypeAccessor::Sort(Sort::$lsort(ctx)))])
                    .finish();)*
				$($(optional_op!(solver, $sort, $lsort, $olsort; $def $args));*);*;
				let sorts = Sorts { $($lsort),* };
                Self { solver, stats: Rc::new(RefCell::new(stats)), sorts }
            }
            pub fn new(solver: Solver<'c>) -> Self {
            	Self::new_with_stats(solver, Default::default())
            }
            $($(optional_fn!($lsort $olsort $def $args);)*)*
			paste!($(
			pub fn [<$lsort _sort>](&self) -> Sort<'c> {
				self.sorts.$lsort.sort.clone()
			}
			pub fn [<$lsort _none>](&self) -> Dynamic<'c> {
				self.sorts.$lsort.variants[0].constructor.apply(&[])
			}
			pub fn [<$lsort _some>](&self, val: $sort<'c>) -> Dynamic<'c> {
				self.sorts.$lsort.variants[1].constructor.apply(&[&val])
			}
			)*);
        }
    }
}

ctx_impl!(
	Real {
		add[a, b] -> Real;
		sub[a, b] -> Real;
		mul[x, y] -> Real;
		unary_minus(x) -> Real;
		div(x, y) -> Real;
		// power(x, y) -> Real;
		lt(x, y) -> Bool;
		le(x, y) -> Bool;
		gt(x, y) -> Bool;
		ge(x, y) -> Bool;
		_eq(x, y) -> Bool;
	};
	Int {
		add[a, b] -> Int;
		sub[x, y] -> Int;
		mul[x, y] -> Int;
		unary_minus(x) -> Int;
		div(x, y) -> Int;
		// rem(x, y) -> Int;
		modulo(x, y) -> Int;
		// power(x, y) -> Int;
		lt(x, y) -> Bool;
		le(x, y) -> Bool;
		gt(x, y) -> Bool;
		ge(x, y) -> Bool;
		_eq(x, y) -> Bool;
		to_real(x) -> Real;
	};
	Bool {
		not(x) -> Bool;
		_eq(x, y) -> Bool;
	};
	String {
		concat[x, y] -> String;
		contains(x, y) -> Bool;
		prefix(x, y) -> Bool;
		suffix(x, y) -> Bool;
		lt(x, y) -> Bool;
		le(x, y) -> Bool;
		gt(x, y) -> Bool;
		ge(x, y) -> Bool;
		_eq(x, y) -> Bool;
	};
);

impl<'c> Ctx<'c> {
	pub fn int_add_v(&self, args: &[&Dynamic<'c>]) -> Dynamic<'c> {
		args.iter().fold(self.int_some(Int::from_i64(self.solver.get_context(), 0)), |a, b| {
			self.int_add(&a, b)
		})
	}

	pub fn int_sub_v(&self, args: &[&Dynamic<'c>]) -> Dynamic<'c> {
		match *args {
			[] => self.int_some(Int::from_i64(self.solver.get_context(), 0)),
			[arg] => self.int_unary_minus(arg),
			[arg, ref args @ ..] => args.iter().fold(arg.clone(), |a, b| self.int_sub(&a, b)),
		}
	}

	pub fn int_mul_v(&self, args: &[&Dynamic<'c>]) -> Dynamic<'c> {
		args.iter().fold(self.int_some(Int::from_i64(self.solver.get_context(), 1)), |a, b| {
			self.int_mul(&a, b)
		})
	}

	pub fn real_add_v(&self, args: &[&Dynamic<'c>]) -> Dynamic<'c> {
		args.iter()
			.fold(self.real_some(Real::from_real(self.solver.get_context(), 0, 1)), |a, b| {
				self.real_add(&a, b)
			})
	}

	pub fn real_sub_v(&self, args: &[&Dynamic<'c>]) -> Dynamic<'c> {
		match *args {
			[] => self.real_some(Real::from_real(self.solver.get_context(), 0, 1)),
			[arg] => self.real_unary_minus(arg),
			[arg, ref args @ ..] => args.iter().fold(arg.clone(), |a, b| self.real_sub(&a, b)),
		}
	}

	pub fn real_mul_v(&self, args: &[&Dynamic<'c>]) -> Dynamic<'c> {
		args.iter()
			.fold(self.real_some(Real::from_real(self.solver.get_context(), 1, 1)), |a, b| {
				self.real_mul(&a, b)
			})
	}

	pub fn bool(&self, val: Option<bool>) -> Dynamic<'c> {
		let ctx = self.solver.get_context();
		match val {
			Some(b) => self.bool_some(Bool::from_bool(ctx, b)),
			None => self.bool_none(),
		}
	}

	pub fn bool_is_true(&self, expr: &Dynamic<'c>) -> Bool<'c> {
		let ctx = self.solver.get_context();
		self.sorts.bool.variants[0].tester.apply(&[expr]).as_bool().unwrap().ite(
			&Bool::from_bool(ctx, false),
			&self.sorts.bool.variants[1].accessors[0].apply(&[expr]).as_bool().unwrap(),
		)
	}

	pub fn bool_and_v(&self, args: &[&Dynamic<'c>]) -> Dynamic<'c> {
		args.iter()
			.fold(self.bool_some(Bool::from_bool(self.solver.get_context(), true)), |a, b| {
				self.bool_and(&a, b)
			})
	}

	pub fn bool_or_v(&self, args: &[&Dynamic<'c>]) -> Dynamic<'c> {
		args.iter()
			.fold(self.bool_some(Bool::from_bool(self.solver.get_context(), false)), |a, b| {
				self.bool_or(&a, b)
			})
	}

	pub fn bool_and(&self, e1: &Dynamic<'c>, e2: &Dynamic<'c>) -> Dynamic<'c> {
		let ctx = self.solver.get_context();
		self.sorts.bool.variants[0].tester.apply(&[e1]).as_bool().unwrap().ite(
			// NULL, b
			&self.sorts.bool.variants[0].tester.apply(&[e2]).as_bool().unwrap().ite(
				// NULL, NULL
				e2,
				// NULL, Some(b)
				&self.sorts.bool.variants[1].accessors[0].apply(&[e2]).as_bool().unwrap().ite(
					// NULL, Some(True)
					&self.bool_none(),
					// NULL, Some(False)
					e2,
				),
			),
			// Some(a), b
			&self.sorts.bool.variants[1].accessors[0].apply(&[e1]).as_bool().unwrap().ite(
				// Some(True), b
				e2,
				// Some(False), b
				&self.bool_some(Bool::from_bool(ctx, false)),
			),
		)
	}

	pub fn bool_or(&self, e1: &Dynamic<'c>, e2: &Dynamic<'c>) -> Dynamic<'c> {
		let ctx = self.solver.get_context();
		self.sorts.bool.variants[0].tester.apply(&[e1]).as_bool().unwrap().ite(
			// NULL, b
			&self.sorts.bool.variants[0].tester.apply(&[e2]).as_bool().unwrap().ite(
				// NULL, NULL
				e2,
				// NULL, Some(b)
				&self.sorts.bool.variants[1].accessors[0].apply(&[e2]).as_bool().unwrap().ite(
					// NULL, Some(True)
					e2,
					// NULL, Some(False)
					&self.bool_none(),
				),
			),
			// Some(a), b
			&self.sorts.bool.variants[1].accessors[0].apply(&[e1]).as_bool().unwrap().ite(
				// Some(True), b
				&self.bool_some(Bool::from_bool(ctx, true)),
				// Some(False), b
				e2,
			),
		)
	}

	pub fn generic_none(&self, ty: impl ToString) -> Dynamic<'c> {
		Dynamic::new_const(
			self.solver.get_context(),
			format!("null!{}", ty.to_string()),
			&self.generic_sort(ty),
		)
	}

	pub fn generic_eq(&self, ty: impl ToString, e1: &Dynamic<'c>, e2: &Dynamic<'c>) -> Dynamic<'c> {
		let none = self.generic_none(ty);
		none._eq(e1).ite(
			&self.bool_none(),
			&none._eq(e2).ite(&self.bool_none(), &self.bool_some(e1._eq(e2))),
		)
	}
}
```

"""pipeline/partial.rs"""
```rust
use std::ops::Mul;

use imbl::{vector, Vector};

use super::shared::{Lambda, Schema};
use crate::pipeline::shared::{DataType, Eval, Neutral as Neut, Terms, Typed, VL};
use crate::pipeline::unify::Unify;
use crate::pipeline::{normal, shared, syntax};

#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Relation(pub Vector<DataType>, pub Env, pub syntax::UExpr);
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Aggr(pub String, pub Vector<DataType>, pub Env, pub syntax::UExpr, pub syntax::Expr);
pub type Expr = shared::Expr<UExpr, Relation, Aggr>;
pub type Logic = shared::Logic<UExpr, Expr>;
pub type Head = shared::Head<Relation, Expr>;
pub type Neutral = shared::Neutral<Relation, Expr>;

impl Typed for Aggr {
	fn ty(&self) -> DataType {
		self.4.ty()
	}
}

impl Relation {
	pub fn app(self, args: Vector<Expr>) -> UExpr {
		let Relation(_, env, body) = self;
		(&env.append(args)).eval(body)
	}

	pub fn degen(&self, env: &normal::Env) -> bool {
		let sum = UExpr::sum(self.clone());
		env.unify(&sum.clone(), &UExpr::logic(Logic::squash(sum)))
	}
}

/// An U-expression in product normal form
pub type UExpr = Terms<Term>;

impl UExpr {
	pub fn logic(logic: Logic) -> Self {
		UExpr::term(Term { logic, ..Term::default() })
	}

	pub fn sum(summand: Relation) -> Self {
		UExpr::term(Term { sums: vector![summand], ..Term::default() })
	}

	pub fn neutral(head: Head, args: Vector<Expr>) -> Self {
		UExpr::term(Term { apps: vector![Neut(head, args)], ..Term::default() })
	}
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Term {
	pub logic: Logic,
	pub apps: Vector<Neutral>,
	pub sums: Vector<Relation>,
}

impl Default for Term {
	fn default() -> Self {
		Term { logic: Logic::tt(), apps: vector![], sums: vector![] }
	}
}

impl Mul for Term {
	type Output = Term;

	fn mul(self, rhs: Self) -> Self::Output {
		let logic = self.logic * rhs.logic;
		let apps = self.apps + rhs.apps;
		let sums = self.sums + rhs.sums;
		Term { logic, apps, sums }
	}
}

pub type NormAgg = (Vector<DataType>, Logic, Vector<Neutral>, Expr);

impl Expr {
	pub fn split(self, aop: &str, context: &Vector<DataType>) -> Vector<NormAgg> {
		match self {
			Expr::Op(op, args, _) if op == aop => {
				args.into_iter().flat_map(|arg| arg.split(aop, context)).collect()
			},
			Expr::Agg(Aggr(op, scope, env, u, e)) if op == aop => {
				let vars = shared::Expr::vars(context.len(), scope.clone());
				let env = &env.append(vars);
				let e = env.eval(e);
				let context = &(context + &scope);
				env.eval(u)
					.into_iter()
					.flat_map(|t| t.split(context))
					.flat_map(|(scp1, l1, apps1)| {
						let scope = &scope;
						e.clone().split(aop, &(context + &scp1)).into_iter().map(
							move |(scp2, l2, apps2, e)| {
								(
									scope + &scp1 + scp2,
									Logic::And(vector![l1.clone(), l2]),
									&apps1 + &apps2,
									e,
								)
							},
						)
					})
					.collect()
			},
			_ => vector![(vector![], Logic::tt(), vector![], self)],
		}
	}
}

pub type NormTerm = (Vector<DataType>, Logic, Vector<Neutral>);

impl Term {
	pub fn split(self, context: &Vector<DataType>) -> Vector<NormTerm> {
		self.splitter(context, vector![])
	}

	fn splitter(mut self, context: &Vector<DataType>, apps: Vector<Neutral>) -> Vector<NormTerm> {
		if let Some(app) = self.apps.pop_front() {
			match app.0 {
				Head::HOp(op, args, _) if op == "limit" && args[0] == 0u32.into() => vector![],
				Head::HOp(op, h_args, rel)
					if ((op == "limit" && h_args[0] == 1u32.into()) && rel.degen(context))
						|| (op == "offset" && h_args[0] == 0u32.into()) =>
				{
					(rel.app(app.1.clone()) * self)
						.into_iter()
						.flat_map(|t| t.splitter(context, apps.clone()))
						.collect()
				},
				_ => self.splitter(context, apps + vector![app]),
			}
		} else if let Some(summand) = self.sums.pop_front() {
			let scope = summand.0.clone();
			let vars = shared::Expr::vars(context.len(), scope.clone());
			let context = &(context + &scope);
			(summand.app(vars) * self)
				.into_iter()
				.flat_map(|t| {
					t.splitter(context, apps.clone())
						.into_iter()
						.map(|(s, l, a)| (&scope + &s, l, a))
				})
				.collect()
		} else {
			vector![(vector![], self.logic, apps)]
		}
	}
}

#[derive(Clone, Debug, Default, Eq, PartialEq)]
pub struct Env(Vector<Expr>, Vector<Schema>);

impl Env {
	pub fn new(subst: Vector<Expr>, schemas: Vector<Schema>) -> Self {
		Env(subst, schemas)
	}

	pub fn append(&self, subst: Vector<Expr>) -> Env {
		Env(self.0.clone() + subst, self.1.clone())
	}
}

impl Eval<syntax::UExpr, UExpr> for &Env {
	fn eval(self, source: syntax::UExpr) -> UExpr {
		use syntax::UExpr::*;
		match source {
			Add(us) => us.into_iter().flat_map(|u| self.eval(u)).collect(),
			Mul(us) => us.into_iter().map(|u| self.eval(u)).fold(UExpr::one(), UExpr::mul),
			Squash(u) => UExpr::logic(Logic::squash(self.eval(*u))),
			Not(u) => UExpr::logic(!Logic::squash(self.eval(*u))),
			Sum(scope, body) => UExpr::sum(Relation(scope, self.clone(), *body)),
			Pred(logic) => UExpr::logic(self.eval(*logic)),
			App(table, args) => self.eval(*table).app(self.eval(args)),
			Neu(Neut(head, args)) => UExpr::neutral(self.eval(head), self.eval(args)),
		}
	}
}

impl Eval<(VL, DataType), Expr> for &Env {
	fn eval(self, (VL(l), ty): (VL, DataType)) -> Expr {
		assert_eq!(self.0[l].ty(), ty, "Wrong type for {}", VL(l));
		self.0[l].clone()
	}
}

impl Eval<syntax::Aggr, Expr> for &Env {
	fn eval(self, syntax::Aggr(op, scope, u, e): syntax::Aggr) -> Expr {
		Expr::Agg(Aggr(op, scope, self.clone(), u, *e))
	}
}

impl Eval<syntax::Relation, Relation> for &Env {
	fn eval(self, Lambda(scope, body): syntax::Relation) -> Relation {
		Relation(scope, self.clone(), body)
	}
}
```

"""pipeline/shared.rs"""
```rust
use std::collections::{HashMap, HashSet};
use std::fmt::{Debug, Display, Formatter, Write};
use std::hash::Hash;
use std::iter::{FromIterator, Product, Sum};
use std::ops::{Add, Mul, Not};
use std::time::Duration;

use anyhow::bail;
use imbl::vector::{ConsumingIter, Iter};
use imbl::{vector, Vector};
use indenter::indented;
use itertools::Itertools;
use serde::{Deserialize, Serialize};
use serde_enum_str::{Deserialize_enum_str, Serialize_enum_str};
use z3::ast::{Ast, Dynamic};
use z3::{Context, FuncDecl, Sort};

pub trait Eval<S, T> {
	fn eval(self, source: S) -> T;
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct VL(pub usize);

impl Display for VL {
	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
		write!(f, "${}", self.0)
	}
}

#[derive(Debug, Clone, Default, Eq, PartialEq, Serialize, Deserialize)]
pub struct Schema {
	pub types: Vec<DataType>,
	#[serde(rename = "key")]
	pub primary: Vec<HashSet<usize>>,
	#[serde(skip)]
	#[serde(rename = "foreign_key")]
	pub foreign: HashMap<usize, VL>,
	#[serde(rename = "nullable")]
	#[serde(default)]
	pub nullabilities: Vec<bool>,
	#[serde(default)]
	pub guaranteed: Vec<super::relation::Expr>,
}

#[derive(Debug, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub enum Expr<U, R, A> {
	Var(VL, DataType),
	Log(Box<Logic<U, Expr<U, R, A>>>),
	Agg(A),
	Op(String, Vec<Expr<U, R, A>>, DataType),
	HOp(String, Vec<Expr<U, R, A>>, Box<R>, DataType),
}

pub trait Typed {
	fn ty(&self) -> DataType;
}

impl<U, R, A: Typed> Typed for Expr<U, R, A> {
	fn ty(&self) -> DataType {
		use Expr::*;
		match self {
			Var(_, ty) | Op(_, _, ty) | HOp(_, _, _, ty) => ty.clone(),
			Log(_) => DataType::Boolean,
			Agg(agg) => agg.ty(),
		}
	}
}

impl<U, R, A: Typed> Expr<U, R, A> {
	pub fn is_null(self) -> Logic<U, Self> {
		Logic::Eq(Self::Op("NULL".to_string(), vec![], self.ty()), self)
	}
}

#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Lambda<U>(pub Vector<DataType>, pub U);

impl<U: Display> Display for Lambda<U> {
	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
		writeln!(f, "(λ {:?}", self.0)?;
		writeln!(indented(f).with_str("\t"), "{})", self.1)
	}
}

#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Sigma<U>(pub Vector<DataType>, pub U);

impl<U: Display> Display for Sigma<U> {
	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
		writeln!(f, "∑ {:?} {{", self.0)?;
		writeln!(indented(f).with_str("\t"), "{}", self.1)?;
		writeln!(f, "}}")
	}
}

#[derive(Debug, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub enum Logic<U, E> {
	Bool(E),
	Eq(E, E),
	Pred(String, Vec<E>),
	Neg(Box<Logic<U, E>>),
	And(Vector<Logic<U, E>>),
	Or(Vector<Logic<U, E>>),
	Squash(Box<U>),
}

impl<U, E> Logic<U, E> {
	pub fn tt() -> Self {
		Logic::And(vector![])
	}

	pub fn ff() -> Self {
		Logic::Or(vector![])
	}

	pub fn squash(u: impl Into<Box<U>>) -> Self {
		Logic::Squash(u.into())
	}
}

impl<U: Clone, E: Clone> Mul for Logic<U, E> {
	type Output = Self;

	fn mul(self, rhs: Self) -> Self::Output {
		use Logic::*;
		match (self, rhs) {
			(And(ls1), And(ls2)) => And(ls1 + ls2),
			(And(ls1), l2) => And(ls1 + vector![l2]),
			(l1, And(ls2)) => And(vector![l1] + ls2),
			(l1, l2) => And(vector![l1, l2]),
		}
	}
}

impl<U: Clone, E: Clone> Product for Logic<U, E> {
	fn product<I: Iterator<Item = Self>>(iter: I) -> Self {
		Logic::And(iter.collect())
	}
}

impl<U: Clone, E: Clone> Add for Logic<U, E> {
	type Output = Self;

	fn add(self, rhs: Self) -> Self::Output {
		use Logic::*;
		match (self, rhs) {
			(Or(ls1), Or(ls2)) => Or(ls1 + ls2),
			(Or(ls1), l2) => Or(ls1 + vector![l2]),
			(l1, Or(ls2)) => Or(vector![l1] + ls2),
			(l1, l2) => Or(vector![l1, l2]),
		}
	}
}

impl<U: Clone, E: Clone> Sum for Logic<U, E> {
	fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {
		Logic::Or(iter.collect())
	}
}

impl<U, E> Not for Logic<U, E> {
	type Output = Self;

	fn not(self) -> Self::Output {
		Logic::Neg(Box::new(self))
	}
}

impl<E: Display, U: Display> Display for Logic<U, E> {
	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
		use Logic::*;
		match self {
			Bool(e) => write!(f, "{}", e),
			Eq(e1, e2) => write!(f, "({} = {})", e1, e2),
			Pred(p, args) => write!(f, "{}({})", p, args.iter().join(", ")),
			Neg(l) => write!(f, "¬{}", l),
			And(ls) if ls.is_empty() => write!(f, "true"),
			And(ls) => write!(f, "({})", ls.iter().format(" ∧ ")),
			Or(ls) if ls.is_empty() => write!(f, "false"),
			Or(ls) => write!(f, "({})", ls.iter().format(" ∨ ")),
			Squash(u) => write!(f, "{}", u),
		}
	}
}

impl<Env, U: Clone, V: Clone, S: Clone, T: Clone> Eval<Logic<U, S>, Logic<V, T>> for Env
where Env: Eval<S, T> + Eval<U, V> + Clone
{
	fn eval(self, source: Logic<U, S>) -> Logic<V, T> {
		use Logic::*;
		match source {
			Bool(e) => Bool(self.eval(e)),
			Eq(e1, e2) => Eq(self.clone().eval(e1), self.eval(e2)),
			Pred(p, args) => Pred(p, self.eval(args)),
			Neg(l) => Neg(self.eval(l)),
			And(ls) => And(self.eval(ls)),
			Or(ls) => Or(self.eval(ls)),
			Squash(u) => Squash(self.eval(u)),
		}
	}
}

impl<U: Clone, R: Clone, A: Clone> Expr<U, R, A> {
	pub fn vars(level: usize, scope: Vector<DataType>) -> Vector<Self> {
		scope.into_iter().enumerate().map(|(l, ty)| Expr::Var(VL(level + l), ty)).collect()
	}
}

impl<U: Display, R: Display, A: Display> Display for Expr<U, R, A> {
	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
		match self {
			Expr::Var(v, _) => write!(f, "{}", v),
			Expr::Log(u) => write!(f, "‖{}‖", u),
			Expr::Agg(agg) => write!(f, "{}", agg),
			Expr::Op(op, args, _) if args.is_empty() => write!(f, "\"{}\"", op),
			Expr::Op(op, args, _) => {
				write!(f, "{}({})", op, args.iter().join(", "))
			},
			Expr::HOp(op, args, rel, _) => write!(f, "{}({}, {})", op, args.iter().join(", "), rel),
		}
	}
}

impl<U, R, A> From<u32> for Expr<U, R, A> {
	fn from(n: u32) -> Self {
		Expr::Op(n.to_string(), vec![], DataType::Integer)
	}
}

impl<U, R, A> From<usize> for Expr<U, R, A> {
	fn from(n: usize) -> Self {
		Expr::Op(n.to_string(), vec![], DataType::Integer)
	}
}

impl<U, R, A> From<String> for Expr<U, R, A> {
	fn from(s: String) -> Self {
		Expr::Op(s, vec![], DataType::String)
	}
}

impl<Env, U: Clone, V: Clone, R: Clone, S: Clone, A: Clone, B: Clone>
	Eval<Expr<U, R, A>, Expr<V, S, B>> for Env
where Env: Eval<(VL, DataType), Expr<V, S, B>>
		+ Eval<U, V>
		+ Eval<R, S>
		+ Eval<A, Expr<V, S, B>>
		+ Clone
{
	fn eval(self, source: Expr<U, R, A>) -> Expr<V, S, B> {
		use Expr::*;
		match source {
			Var(l, ty) => self.eval((l, ty)),
			Log(l) => Log(self.eval(l)),
			Agg(agg) => self.eval(agg),
			Op(f, args, ty) => Op(f, self.eval(args), ty),
			HOp(f, args, rel, ty) => HOp(f, self.clone().eval(args), self.eval(rel), ty),
		}
	}
}

#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub enum Head<R, E> {
	Var(VL),
	HOp(String, Vec<E>, Box<R>),
}

impl<R: Display, E: Display> Display for Head<R, E> {
	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
		match self {
			Head::Var(VL(l)) => write!(f, "#{}", l),
			Head::HOp(op, op_args, rel) => {
				writeln!(f, "#{}({}, {})", op, op_args.iter().format(", "), rel)
			},
		}
	}
}

impl<Env, R: Clone, S: Clone, E: Clone, F: Clone> Eval<Head<R, E>, Head<S, F>> for Env
where Env: Eval<R, S> + Eval<Vec<E>, Vec<F>> + Clone
{
	fn eval(self, source: Head<R, E>) -> Head<S, F> {
		use Head::*;
		match source {
			Var(v) => Var(v),
			HOp(op, args, rel) => HOp(op, self.clone().eval(args), self.eval(*rel).into()),
		}
	}
}

#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Neutral<R, E>(pub Head<R, E>, pub Vector<E>);

impl<R: Display, E: Display> Display for Neutral<R, E> {
	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
		write!(f, "{}({})", self.0, self.1.iter().format(", "))
	}
}

impl<Env, R: Clone, S: Clone, E: Clone, F: Clone> Eval<Neutral<R, E>, Neutral<S, F>> for Env
where Env: Eval<Head<R, E>, Head<S, F>> + Eval<Vector<E>, Vector<F>> + Clone
{
	fn eval(self, Neutral(head, args): Neutral<R, E>) -> Neutral<S, F> {
		let head = self.clone().eval(head);
		let args = self.eval(args);
		Neutral(head, args)
	}
}

/// SQL data types (adapted from sqlparser)
#[derive(
	Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize_enum_str, Deserialize_enum_str,
)]
#[serde(rename_all = "UPPERCASE")]
pub enum DataType {
	/// Integer
	#[serde(alias = "INT", alias = "SMALLINT", alias = "BIGINT", alias = "TINYINT")]
	#[serde(alias = "TIMESTAMP", alias = "DATE", alias = "TIME")]
	Integer,
	/// Real number
	#[serde(alias = "FLOAT", alias = "DOUBLE", alias = "DECIMAL")]
	Real,
	/// Boolean
	#[serde(alias = "BOOL")]
	Boolean,
	/// String
	#[serde(alias = "VARCHAR", alias = "CHAR", alias = "TEXT")]
	String,
	/// Custom type such as enums
	#[serde(other)]
	Custom(String),
}

#[derive(Clone, Debug, Default, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub struct Terms<T>(pub Vector<T>);

impl<T> Terms<T> {
	pub fn zero() -> Self {
		Terms(vector![])
	}

	pub fn iter(&self) -> Iter<'_, T> {
		self.0.iter()
	}
}

impl<T: Clone> Terms<T> {
	pub fn term(term: T) -> Self {
		Terms(vector![term])
	}

	pub fn into_iter(self) -> ConsumingIter<T> {
		self.0.into_iter()
	}
}

impl<T: Clone + Default> Terms<T> {
	pub fn one() -> Self {
		Terms::term(T::default())
	}
}

impl<T: Clone> IntoIterator for Terms<T> {
	type Item = T;
	type IntoIter = ConsumingIter<T>;

	fn into_iter(self) -> Self::IntoIter {
		self.into_iter()
	}
}

impl<'a, T> IntoIterator for &'a Terms<T> {
	type Item = &'a T;
	type IntoIter = Iter<'a, T>;

	fn into_iter(self) -> Self::IntoIter {
		self.iter()
	}
}

impl<T: Clone> FromIterator<T> for Terms<T> {
	fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
		Terms(iter.into_iter().collect())
	}
}

impl<T: Clone> Add for Terms<T> {
	type Output = Terms<T>;

	fn add(self, rhs: Self) -> Self::Output {
		Terms(self.0 + rhs.0)
	}
}

impl<T: Clone + Mul> Mul for Terms<T>
where T::Output: Clone
{
	type Output = Terms<T::Output>;

	fn mul(self, rhs: Self) -> Self::Output {
		self.into_iter().flat_map(|t1| rhs.iter().map(move |t2| t1.clone() * t2.clone())).collect()
	}
}

impl<T: Clone + Mul> Mul<T> for Terms<T>
where T::Output: Clone
{
	type Output = Terms<T::Output>;

	fn mul(self, rhs: T) -> Self::Output {
		self.into_iter().map(|term| term * rhs.clone()).collect()
	}
}

impl<T: Display> Display for Terms<T> {
	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
		write!(f, "{}", self.iter().join("\n+ "))
	}
}

impl<E, S: Clone, T: Clone> Eval<Vector<S>, Vector<T>> for E
where E: Eval<S, T> + Clone
{
	fn eval(self, source: Vector<S>) -> Vector<T> {
		source.into_iter().map(|item| self.clone().eval(item)).collect()
	}
}

impl<'a, E, S: Clone, T: Clone> Eval<&'a Vector<S>, Vector<T>> for E
where E: Eval<&'a S, T> + Clone
{
	fn eval(self, source: &'a Vector<S>) -> Vector<T> {
		source.iter().map(|item| self.clone().eval(item)).collect()
	}
}

impl<E, S, T> Eval<Vec<S>, Vec<T>> for E
where E: Eval<S, T> + Clone
{
	fn eval(self, source: Vec<S>) -> Vec<T> {
		source.into_iter().map(|item| self.clone().eval(item)).collect()
	}
}

impl<E, S, T> Eval<Box<S>, Box<T>> for E
where E: Eval<S, T>
{
	fn eval(self, source: Box<S>) -> Box<T> {
		self.eval(*source).into()
	}
}

impl<E, S, T> Eval<Option<S>, Option<T>> for E
where E: Eval<S, T>
{
	fn eval(self, source: Option<S>) -> Option<T> {
		source.map(|item| self.eval(item))
	}
}

pub use super::null::Ctx;

impl<'c> Ctx<'c> {
	pub fn z3_ctx(&self) -> &'c Context {
		self.solver.get_context()
	}

	pub fn none(&self, ty: &DataType) -> anyhow::Result<Dynamic<'c>> {
		use DataType::*;
		Ok(match ty {
			Integer => self.int_none(),
			Real => self.real_none(),
			Boolean => self.bool_none(),
			String => self.string_none(),
			_ => bail!("unsupported type {:?} for null", ty),
		})
	}

	pub fn sort(&self, ty: &DataType) -> Sort<'c> {
		use DataType::*;
		match ty {
			Boolean => self.bool_sort(),
			String => self.string_sort(),
			Integer => self.int_sort(),
			Real => self.real_sort(),
			Custom(ty) => self.generic_sort(ty),
		}
	}

	pub fn generic_sort(&self, ty: impl ToString) -> Sort<'c> {
		Sort::uninterpreted(self.z3_ctx(), z3::Symbol::String(ty.to_string()))
	}

	pub fn strict_sort(&self, ty: &DataType) -> Sort<'c> {
		let z3_ctx = self.z3_ctx();
		use DataType::*;
		match ty {
			Boolean => Sort::bool(z3_ctx),
			String => Sort::string(z3_ctx),
			Integer => Sort::int(z3_ctx),
			Real => Sort::real(z3_ctx),
			_ => panic!("unsupported type {:?}", ty),
		}
	}

	pub fn var(&self, ty: &DataType, prefix: &str) -> Dynamic<'c> {
		Dynamic::fresh_const(self.solver.get_context(), prefix, &self.sort(ty))
	}

	pub fn app(
		&self,
		name: &str,
		args: &[&Dynamic<'c>],
		range: &DataType,
		nullable: bool,
	) -> Dynamic<'c> {
		let ctx = self.solver.get_context();
		let domain = args.iter().map(|arg| arg.get_sort()).collect_vec();
		let args = args.iter().map(|&arg| arg as &dyn Ast).collect_vec();
		let range = if nullable { self.sort(range) } else { self.strict_sort(range) };
		let f = FuncDecl::new(ctx, name, &domain.iter().collect_vec(), &range);
		f.apply(&args)
	}

	pub fn timeout() -> Duration {
		if let Some(t) = std::env::var("QED_SMT_TIMEOUT").ok().and_then(|t| t.parse::<u64>().ok()) {
			Duration::from_millis(t)
		} else {
			Duration::from_secs(10)
		}
	}

	pub fn update_smt_duration(&self, duration: Duration, timed_out: bool) {
		let mut stats = self.stats.borrow_mut();
		stats.smt_duration += duration;
		stats.smt_timed_out |= timed_out;
	}

	pub fn update_equiv_class_duration(&self, duration: Duration, timed_out: bool) {
		let mut stats = self.stats.borrow_mut();
		stats.equiv_class_duration += duration;
		stats.equiv_class_timed_out |= timed_out;
	}
}
```

"""pipeline/stable.rs"""
```rust
use std::collections::BTreeMap;
use std::time::Instant;

use imbl::{vector, HashSet, Vector};
use itertools::Itertools;
use z3::ast::Ast;
use z3::SatResult;

use super::normal::Z3Env;
use super::shared::{Ctx, DataType, Eval, Lambda, Sigma, Terms};
use crate::pipeline::normal;
use crate::pipeline::shared::{self, Typed, VL};

#[derive(Clone)]
pub struct Aggr<'c>(
	pub String,
	pub Vector<DataType>,
	pub Env<'c>,
	pub normal::Inner,
	pub normal::Expr,
);

impl Typed for Aggr<'_> {
	fn ty(&self) -> DataType {
		self.4.ty()
	}
}

pub type Expr<'c> = shared::Expr<UExpr<'c>, Relation<'c>, Aggr<'c>>;
pub type Neutral<'c> = shared::Neutral<Relation<'c>, Expr<'c>>;
pub type Logic<'c> = shared::Logic<UExpr<'c>, Expr<'c>>;

#[derive(Clone)]
pub struct Relation<'c>(pub Vector<DataType>, pub Env<'c>, pub normal::UExpr);
pub type UExpr<'c> = Terms<Term<'c>>;

// Env(subst: C -> stb::Expr D, z3: C -> z3::Expr): Eval (nom::Expr C) (stb::Expr D)
#[derive(Clone)]
pub struct Env<'c>(pub Vector<Option<Expr<'c>>>, pub Z3Env<'c>);

impl<'c> Env<'c> {
	pub fn append(&self, subst: Vector<Option<Expr<'c>>>) -> Self {
		Env(self.0.clone() + subst, self.1.clone())
	}

	pub fn extend(&self, base: usize, scope: Vector<DataType>) -> Self {
		let vars = shared::Expr::vars(base, scope.clone()).into_iter().map(Some).collect();
		Env(self.0.clone() + vars, self.1.extend(&scope))
	}
}

#[derive(Clone)]
pub struct Term<'c>(pub Vector<DataType>, pub Env<'c>, pub normal::Inner);

impl<'c> Eval<(VL, DataType), Expr<'c>> for &Env<'c> {
	fn eval(self, (VL(l), _): (VL, DataType)) -> Expr<'c> {
		self.0[l].clone().unwrap()
	}
}

impl<'c> Eval<normal::Relation, Relation<'c>> for &Env<'c> {
	fn eval(self, Lambda(scope, body): normal::Relation) -> Relation<'c> {
		Relation(scope, self.clone(), body)
	}
}

impl<'c> Eval<normal::Aggr, Expr<'c>> for &Env<'c> {
	fn eval(self, normal::Aggr(op, scope, i, e): normal::Aggr) -> Expr<'c> {
		Expr::Agg(Aggr(op, scope, self.clone(), *i, *e))
	}
}

impl<'c> Eval<normal::UExpr, UExpr<'c>> for &Env<'c> {
	fn eval(self, source: normal::UExpr) -> UExpr<'c> {
		source.into_iter().map(|term| self.eval(term)).collect()
	}
}

// env : C -> stb::Expr D
// cong : [(Id, nom::Expr (C + S))]
// S', C + S -> stb::Expr (D + S')
pub fn min_subst<'c>(
	env: &Env<'c>,
	scope: Vector<DataType>,
	context: &Vector<DataType>,
	cong: &[(u32, &normal::Expr)],
) -> (Vector<DataType>, Vector<Option<Expr<'c>>>) {
	let groups = cong.iter().copied().into_group_map();
	let Env(subst, _) = env;
	let level = subst.len();
	let bound = level..level + scope.len();
	let vars = bound.clone().map(VL);
	let var_groups = vars.clone().map(|v| {
		(
			v,
			cong.iter()
				.find(|&&(_, e)| e == &normal::Expr::Var(v, e.ty()))
				.map(|(g, _)| groups.get(g).unwrap()),
		)
	});
	let mut new_scope = Vector::new();
	let mut keys: HashSet<_> = vars.clone().collect();
	let mut deps_map = BTreeMap::new();

	fn root_deps(vars: &HashSet<VL>, deps_map: &BTreeMap<VL, HashSet<VL>>) -> HashSet<VL> {
		let saturate = |var, deps: &BTreeMap<_, _>| {
			deps.get(&var).map_or_else(|| HashSet::unit(var), |vars| root_deps(vars, deps))
		};
		HashSet::unions(vars.iter().map(|&v| saturate(v, deps_map)))
	}

	let (exprs, mut var_subst) = var_groups
		.zip(scope.clone())
		.map(|((v, es), ty)| {
			keys.remove(&v);
			if let Some((_, deps, expr)) = es
				.into_iter()
				.flatten()
				.filter_map(|&expr| {
					let deps = expr.deps(&bound);
					let root_deps = root_deps(&deps, &deps_map);
					root_deps.is_subset(&keys).then(|| (root_deps.len(), deps, expr))
				})
				.min_by_key(|a| a.0)
			{
				log::info!("[dep] {} -> {}", v, expr);
				deps_map.insert(v, deps);
				(expr.clone(), None)
			} else {
				keys.insert(v);
				let new_v = VL(context.len() + new_scope.len());
				log::info!("[key] {} ~> {}", v, new_v);
				new_scope.push_back(ty.clone());
				(normal::Expr::Var(v, ty.clone()), Some(Expr::Var(new_v, ty)))
			}
		})
		.unzip();
	// Ensures v is mapped to some Expr
	fn prune<'c>(
		v: VL,
		deps_map: &mut BTreeMap<VL, HashSet<VL>>,
		var_subst: &mut Vector<Option<Expr<'c>>>,
		exprs: &Vec<normal::Expr>,
		env: &Env<'c>,
	) {
		if let Some((v, deps)) = deps_map.remove_entry(&v) {
			deps.into_iter().for_each(|w| prune(w, deps_map, var_subst, exprs, env));
			let i = v.0 - env.0.len();
			var_subst[i] = Some((&env.append(var_subst.clone())).eval(exprs[i].clone()));
		};
	}

	while let Some((&v, _)) = deps_map.first_key_value() {
		prune(v, &mut deps_map, &mut var_subst, &exprs, env);
	}
	(new_scope, var_subst)
}

impl<'c> Eval<normal::Term, Term<'c>> for &Env<'c> {
	fn eval(self, Sigma(scope, inner): normal::Term) -> Term<'c> {
		Term(scope, self.clone(), inner)
	}
}

pub type NormAgg<'c> = (Vector<DataType>, Logic<'c>, Vector<Neutral<'c>>, Expr<'c>);

impl<'c> Expr<'c> {
	pub fn split(self, aop: &str, context: &Vector<DataType>) -> Vector<NormAgg<'c>> {
		match self {
			Expr::Op(op, args, _) if op == aop => {
				args.into_iter().flat_map(|arg| arg.split(aop, context)).collect()
			},
			Expr::Agg(Aggr(op, old_scope, env, i, e)) if op == aop => {
				if let Some((scope, new_subst)) =
					stablize(&env, old_scope.clone(), context, i.logic.clone())
				{
					let Env(subst, z3_env) = env;
					let env = &Env(subst + new_subst, z3_env.extend(&old_scope));
					let logic = env.eval(i.logic);
					let apps = env.eval(i.apps);
					env.eval(e)
						.split(aop, &(context + &scope))
						.into_iter()
						.map(|(scp, l, aps, e)| {
							(&scope + &scp, Logic::And(vector![logic.clone(), l]), &apps + &aps, e)
						})
						.collect()
				} else {
					vector![]
				}
			},
			_ => vector![(vector![], Logic::tt(), vector![], self)],
		}
	}
}

// Env: C -> stb::Expr D
// C + S ~> C + S'
pub fn stablize<'c>(
	env: &Env<'c>,
	scope: Vector<DataType>,
	context: &Vector<DataType>,
	logic: normal::Logic,
) -> Option<(Vector<DataType>, Vector<Option<Expr<'c>>>)> {
	let Env(subst, z3_env) = env;
	let z3_env = &z3_env.extend(&scope);
	let solver = &z3_env.ctx.solver;
	let constraint = z3_env.eval(&logic);
	let vars = shared::Expr::vars(subst.len(), scope.clone());
	let exprs = vars
		.iter()
		.chain(logic.exprs())
		.filter(|e| e.in_scope(subst.len() + scope.len()))
		.unique()
		.collect_vec();
	let z3_asts = exprs.iter().map(|&e| z3_env.eval(e)).collect_vec();
	let z3_asts = z3_asts.iter().map(|e| e as &dyn Ast).collect_vec();
	solver.push();
	solver.assert(&constraint);
	let handle = solver.get_context().handle();
	let checked = crossbeam::atomic::AtomicCell::new(false);
	let timed_out = crossbeam::atomic::AtomicCell::new(false);
	let equiv_start = Instant::now();
	let (ids, res) = std::thread::scope(|s| {
		let checked = &checked;
		let timed_out = &timed_out;
		let p = crossbeam::sync::Parker::new();
		let u = p.unparker().clone();
		s.spawn(move || {
			p.park_timeout(Ctx::timeout());
			if !checked.load() {
				timed_out.store(true);
				handle.interrupt();
			}
		});
		let (ids, res) = solver.get_implied_equalities(z3_asts.as_slice());
		checked.store(true);
		u.unpark();
		(ids, res)
	});
	z3_env.ctx.update_equiv_class_duration(equiv_start.elapsed(), timed_out.into_inner());
	solver.pop(1);
	match res {
		SatResult::Unsat => None,
		SatResult::Unknown => {
			let vars = Expr::vars(context.len(), scope.clone()).into_iter().map(Some).collect();
			Some((scope, vars))
		},
		SatResult::Sat => {
			let groups = ids.into_iter().zip(exprs).collect_vec();
			log::info!(
				"Congruence groups: {}",
				groups.iter().map(|(g, e)| format!("[{}, {}]", g, e)).join(", ")
			);
			let env = &Env(subst.clone(), z3_env.clone());
			Some(min_subst(env, scope, context, &groups))
		},
	}
}
```

"""pipeline/syntax.rs"""
```rust
use std::fmt::{Debug, Display, Formatter, Write};
use std::ops::{Add, Mul, Not};

use imbl::{vector, Vector};
use indenter::indented;
use itertools::Itertools;
use UExpr::*;

use super::shared::{Lambda, Neutral, Typed};
use crate::pipeline::shared;
use crate::pipeline::shared::DataType;

pub type Relation = Lambda<UExpr>;
pub type Expr = shared::Expr<UExpr, Relation, Aggr>;
pub type Logic = shared::Logic<UExpr, Expr>;

#[derive(Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub struct Aggr(pub String, pub Vector<DataType>, pub UExpr, pub Box<Expr>);

impl Display for Aggr {
	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
		let Aggr(name, scope, uexpr, expr) = self;
		write!(f, "⨿{} {:?} {{", name, scope)?;
		writeln!(indented(f).with_str("\t"), "{},", uexpr)?;
		writeln!(indented(f).with_str("\t"), "{}", expr)?;
		write!(f, "}}")
	}
}

impl Typed for Aggr {
	fn ty(&self) -> DataType {
		self.3.ty()
	}
}

/// An expression that evaluates to a U-semiring value.
/// This include all constants and operation defined over the U-semiring,
/// as well as the result of a predicate and application of a relation with some arguments.
#[derive(Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub enum UExpr {
	// Addition
	Add(Vector<UExpr>),
	// Multiplication
	Mul(Vector<UExpr>),
	// Squash operator
	Squash(Box<UExpr>),
	// Not operator
	Not(Box<UExpr>),
	// Summation that ranges over tuples of certain schema
	Sum(Vector<DataType>, Box<UExpr>),
	// Predicate that can be evaluated to 0 or 1
	Pred(Box<Logic>),
	// Application of a lambda with arguments
	App(Box<Relation>, Vector<Expr>),
	// Neutral application
	Neu(Neutral<Relation, Expr>),
}

impl UExpr {
	pub fn zero() -> Self {
		UExpr::Add(vector![])
	}

	pub fn one() -> Self {
		UExpr::Mul(vector![])
	}

	pub fn sum(scope: impl Into<Vector<DataType>>, body: impl Into<Box<UExpr>>) -> Self {
		Sum(scope.into(), body.into())
	}

	pub fn squash(body: impl Into<Box<UExpr>>) -> Self {
		Squash(body.into())
	}

	pub fn pred(l: Logic) -> Self {
		Pred(l.into())
	}

	pub fn app(rel: impl Into<Box<Relation>>, args: Vector<Expr>) -> Self {
		App(rel.into(), args)
	}
}

impl Display for UExpr {
	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
		match self {
			Add(us) if us.is_empty() => write!(f, "0"),
			Add(us) => write!(f, "({})", us.iter().format(" + ")),
			Mul(us) if us.is_empty() => write!(f, "1"),
			Mul(us) => write!(f, "({})", us.iter().format(" × ")),
			Squash(u) => write!(f, "‖{}‖", u),
			Not(u) => write!(f, "¬({})", u),
			Sum(scope, body) => {
				writeln!(f, "∑ {:?} {{", scope)?;
				writeln!(indented(f).with_str("\t"), "{}", body)?;
				write!(f, "}}")
			},
			Pred(logic) => write!(f, "⟦{}⟧", logic),
			App(rel, args) => {
				write!(f, "{}({})", rel, args.iter().join(", "))
			},
			Neu(Neutral(head, args)) => {
				write!(f, "{}({})", head, args.iter().join(", "))
			},
		}
	}
}

// The following overload the +, *, and ! operators for UExpr, so that we can construct an expression
// in a natural way.

impl Add<UExpr> for UExpr {
	type Output = UExpr;

	fn add(self, rhs: UExpr) -> Self::Output {
		match (self, rhs) {
			(Add(us1), Add(us2)) => Add(us1 + us2),
			(Add(us1), u2) => Add(us1 + vector![u2]),
			(u1, Add(us2)) => Add(vector![u1] + us2),
			(t1, t2) => Add(vector![t1] + vector![t2]),
		}
	}
}

impl Mul<UExpr> for UExpr {
	type Output = UExpr;

	fn mul(self, rhs: UExpr) -> Self::Output {
		match (self, rhs) {
			(Mul(us1), Mul(us2)) => Mul(us1 + us2),
			(Mul(us1), u2) => Mul(us1 + vector![u2]),
			(u1, Mul(us2)) => Mul(vector![u1] + us2),
			(t1, t2) => Mul(vector![t1] + vector![t2]),
		}
	}
}

impl Not for UExpr {
	type Output = UExpr;

	fn not(self) -> Self::Output {
		Not(self.into())
	}
}
```

"""pipeline/tests.rs"""
```rust

```

"""pipeline/normal.rs"""
```rust
use std::cell::RefCell;
use std::collections::HashMap;
use std::fmt::{Display, Formatter, Write};
use std::ops::Range;
use std::rc::Rc;

use anyhow::bail;
use imbl::{vector, HashSet, Vector};
use indenter::indented;
use itertools::Itertools;
use num::ToPrimitive;
use z3::ast::{exists_const, Ast, Bool, Dynamic, Int, Real as Re, String as Str};
use z3::{Config, Context, Solver};

use super::shared::{Ctx, Lambda, Sigma, Typed};
use super::stable::{self, stablize};
use super::unify::{Unify, UnifyEnv};
use crate::pipeline::relation::{num_cmp, num_op};
use crate::pipeline::relation as rel;
use crate::pipeline::shared::{DataType, Eval, Neutral as Neut, Terms, VL};
use crate::pipeline::{partial, shared};
use crate::pipeline::constraint;

pub type Relation = Lambda<UExpr>;

pub type Expr = shared::Expr<UExpr, Relation, Aggr>;
pub type Neutral = shared::Neutral<Relation, Expr>;
pub type Head = shared::Head<Relation, Expr>;
pub type Logic = shared::Logic<UExpr, Expr>;

pub type Term = Sigma<Inner>;
pub type UExpr = Terms<Term>;

impl UExpr {
	pub fn under(scope: Vector<DataType>, terms: UExpr) -> Self {
		terms.into_iter().map(|term| Sigma(scope.clone() + term.0, term.1)).collect()
	}
}

#[derive(Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub struct Aggr(pub String, pub Vector<DataType>, pub Box<Inner>, pub Box<Expr>);

impl Display for Aggr {
	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
		let Aggr(name, scope, uexpr, expr) = self;
		writeln!(f, "⨿{} {:?} {{", name, scope)?;
		writeln!(indented(f).with_str("\t"), "{},", uexpr)?;
		writeln!(indented(f).with_str("\t"), "{}", expr)?;
		write!(f, "}}")
	}
}

impl Typed for Aggr {
	fn ty(&self) -> DataType {
		self.3.ty()
	}
}

impl Aggr {
	pub fn under(scope: Vector<DataType>, aggs: Vector<Aggr>) -> Vector<Aggr> {
		aggs.into_iter().map(|Aggr(op, scp, u, e)| Aggr(op, scope.clone() + scp, u, e)).collect()
	}
}

#[derive(Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub struct Inner {
	pub logic: Logic,
	pub apps: Vector<Neutral>,
}

impl Display for Inner {
	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
		write!(f, "⟦{}⟧ × ({})", self.logic, self.apps.iter().format(" × "))
	}
}

impl Inner {
	pub(crate) fn in_scope(&self, lvl: usize) -> bool {
		self.logic.in_scope(lvl) && self.apps.iter().all(|app| app.in_scope(lvl))
	}
}

impl Aggr {
	pub(crate) fn deps(&self, vars: &Range<usize>) -> HashSet<VL> {
		let Aggr(_, _, u, e) = self;
		e.deps(vars) + u.logic.deps(vars) + HashSet::unions(u.apps.iter().map(|app| app.deps(vars)))
	}

	pub(crate) fn in_scope(&self, lvl: usize) -> bool {
		let Aggr(_, scope, u, e) = self;
		u.in_scope(lvl + scope.len()) && e.in_scope(lvl + scope.len())
	}
}

impl Expr {
	pub(crate) fn deps(&self, vars: &Range<usize>) -> HashSet<VL> {
		match self {
			Expr::Var(v, _) if vars.contains(&v.0) => HashSet::unit(*v),
			Expr::Var(_, _) => HashSet::new(),
			Expr::Log(l) => l.deps(vars),
			Expr::Agg(agg) => agg.deps(vars),
			Expr::Op(_, args, _) => HashSet::unions(args.iter().map(|arg| arg.deps(vars))),
			Expr::HOp(_, args, rel, _) => {
				HashSet::unions(args.iter().map(|arg| arg.deps(vars))) + rel.deps(vars)
			},
		}
	}

	pub(crate) fn in_scope(&self, lvl: usize) -> bool {
		match self {
			Expr::Var(VL(l), _) => *l < lvl,
			Expr::Log(l) => l.in_scope(lvl),
			Expr::Agg(agg) => agg.in_scope(lvl),
			Expr::Op(_, args, _) => args.iter().all(|arg| arg.in_scope(lvl)),
			Expr::HOp(_, args, rel, _) => {
				args.iter().all(|arg| arg.in_scope(lvl)) && rel.in_scope(lvl)
			},
		}
	}

	fn exprs(&self) -> Vector<&Expr> {
		match self {
			Expr::Log(l) => l.exprs(),
			Expr::Op(op, es, ty)
				if matches!(
					op.as_str(),
					"=" | "EQ" | "<=" | "LE" | "<" | "LT" | ">=" | "GE" | ">" | "GT"
				) && es.len() == 2 && ty == &DataType::Boolean =>
			{
				es.iter().collect()
			},
			Expr::Op(_, es, _) | Expr::HOp(_, es, _, _) => {
				es.iter().flat_map(Expr::exprs).collect()
			},
			_ => vector![],
		}
	}
}

impl UExpr {
	fn deps(&self, vars: &Range<usize>) -> HashSet<VL> {
		HashSet::unions(self.iter().map(|t| t.deps(vars)))
	}

	fn in_scope(&self, lvl: usize) -> bool {
		self.iter().all(|t| t.in_scope(lvl))
	}

	fn exprs(&self) -> Vector<&Expr> {
		self.iter().flat_map(Term::exprs).collect()
	}
}

impl Relation {
	fn deps(&self, vars: &Range<usize>) -> HashSet<VL> {
		self.1.deps(vars)
	}

	fn in_scope(&self, lvl: usize) -> bool {
		let Lambda(scope, body) = self;
		body.in_scope(lvl + scope.len())
	}

	fn exprs(&self) -> Vector<&Expr> {
		self.1.exprs()
	}
}

impl Term {
	fn deps(&self, vars: &Range<usize>) -> HashSet<VL> {
		let Sigma(_, Inner { logic, apps }) = self;
		logic.deps(vars) + HashSet::unions(apps.iter().map(|app| app.deps(vars)))
	}

	fn in_scope(&self, lvl: usize) -> bool {
		let Sigma(scope, Inner { logic, apps }) = self;
		let lvl = lvl + scope.len();
		logic.in_scope(lvl) && apps.iter().all(|app| app.in_scope(lvl))
	}

	fn exprs(&self) -> Vector<&Expr> {
		let Sigma(_, Inner { logic, apps }) = self;
		logic.exprs() + apps.iter().flat_map(Neutral::exprs).collect()
	}
}

impl Neutral {
	fn deps(&self, vars: &Range<usize>) -> HashSet<VL> {
		let Neut(head, args) = self;
		(match &head {
			Head::Var(_) => HashSet::new(),
			Head::HOp(_, args, rel) => {
				rel.deps(vars) + HashSet::unions(args.iter().map(|arg| arg.deps(vars)))
			},
		}) + HashSet::unions(args.iter().map(|arg| arg.deps(vars)))
	}

	fn in_scope(&self, lvl: usize) -> bool {
		let Neut(head, args) = self;
		(match &head {
			Head::Var(_) => true,
			Head::HOp(_, args, rel) => {
				args.iter().all(|arg| arg.in_scope(lvl)) && rel.in_scope(lvl)
			},
		}) && args.iter().all(|arg| arg.in_scope(lvl))
	}

	fn exprs(&self) -> Vector<&Expr> {
		let Neut(head, args) = self;
		(match &head {
			Head::Var(_) => vector![],
			Head::HOp(_, args, rel) => {
				args.iter().flat_map(Expr::exprs).chain(rel.exprs()).collect()
			},
		}) + args.iter().flat_map(Expr::exprs).collect()
	}
}

impl Logic {
	fn deps(&self, vars: &Range<usize>) -> HashSet<VL> {
		use shared::Logic::*;
		match self {
			Bool(e) => e.deps(vars),
			Eq(e1, e2) => e1.deps(vars) + e2.deps(vars),
			Pred(_, args) => HashSet::unions(args.iter().map(|arg| arg.deps(vars))),
			Neg(l) => l.deps(vars),
			And(ls) | Or(ls) => HashSet::unions(ls.iter().map(|l| l.deps(vars))),
			Squash(u) => u.deps(vars),
		}
	}

	fn in_scope(&self, lvl: usize) -> bool {
		use shared::Logic::*;
		match self {
			Bool(e) => e.in_scope(lvl),
			Eq(e1, e2) => e1.in_scope(lvl) && e2.in_scope(lvl),
			Pred(_, args) => args.iter().all(|arg| arg.in_scope(lvl)),
			Neg(l) => l.in_scope(lvl),
			And(ls) | Or(ls) => ls.iter().all(|l| l.in_scope(lvl)),
			Squash(u) => u.in_scope(lvl),
		}
	}

	fn simpl(self) -> Self {
		use shared::Logic::*;
		match self {
			Eq(e1, e2) if e1 == e2 => Logic::tt(),
			Bool(Expr::Op(p, es, _)) if p == "=" && es.len() == 2 && es[0] == es[1] => {
				!es[0].clone().is_null()
			},
			And(ls) => And(ls
				.into_iter()
				.flat_map(|l| match l.simpl() {
					And(ls) => ls,
					l => vector![l],
				})
				.collect()),
			Or(ls) => Or(ls
				.into_iter()
				.flat_map(|l| match l.simpl() {
					Or(ls) => ls,
					l => vector![l],
				})
				.collect()),
			Neg(l) => Neg(l.simpl().into()),
			l => l,
		}
	}

	pub(crate) fn exprs(&self) -> Vector<&Expr> {
		use shared::Logic::*;
		match self {
			Bool(e) => e.exprs(),
			Pred(_, es) => es.iter().flat_map(Expr::exprs).collect(),
			Eq(e1, e2) => vector![e1, e2] + e1.exprs() + e2.exprs(),
			Neg(l) => l.exprs(),
			And(ls) => ls.iter().flat_map(Logic::exprs).collect(),
			Or(ls) => ls.iter().flat_map(Logic::exprs).collect(),
			Squash(u) => u.exprs(),
		}
	}
}

pub type Env = Vector<DataType>;

impl Eval<partial::Aggr, Expr> for &Env {
	fn eval(self, agg: partial::Aggr) -> Expr {
		use shared::Expr::*;
		let op = agg.0.clone();
		let ty = agg.ty();
		let es = Agg(agg).split(&op, self).into_iter().map(|(scp, l, apps, e)| {
			let env = &(self + &scp);
			let inner = Inner { logic: env.eval(l), apps: env.eval(apps) };
			Agg(Aggr(op.clone(), scp, Box::new(inner), Box::new(env.eval(e))))
		});
		Op(op.clone(), es.collect(), ty)
	}
}

impl Eval<partial::UExpr, UExpr> for &Env {
	fn eval(self, source: partial::UExpr) -> UExpr {
		source
			.into_iter()
			.flat_map(|t| t.split(self))
			.map(|(scp, l, apps)| {
				let env = &(self + &scp);
				Sigma(scp, Inner { logic: env.eval(l), apps: env.eval(apps) })
			})
			.collect()
	}
}

impl Eval<(VL, DataType), Expr> for &Env {
	fn eval(self, source: (VL, DataType)) -> Expr {
		Expr::Var(source.0, source.1)
	}
}

impl Eval<partial::Relation, Relation> for &Env {
	fn eval(self, source: partial::Relation) -> Relation {
		let partial::Relation(scope, clos_env, body) = source;
		let env = &(self + &scope);
		let vars = shared::Expr::vars(self.len(), scope.clone());
		let body: partial::UExpr = (&clos_env.append(vars)).eval(body);
		Lambda(scope, env.eval(body))
	}
}

impl<'c> Eval<stable::Relation<'c>, Relation> for &Env {
	fn eval(self, stable::Relation(scope, env, body): stable::Relation<'c>) -> Relation {
		let body = (&env.extend(self.len(), scope.clone())).eval(body);
		Lambda(scope.clone(), (&(self + &scope)).eval(body))
	}
}

impl<'c> Eval<stable::UExpr<'c>, UExpr> for &Env {
	fn eval(self, source: stable::UExpr<'c>) -> UExpr {
		source.into_iter().filter_map(|t| self.eval(t)).collect()
	}
}

impl<'c> Eval<stable::Term<'c>, Option<Term>> for &Env {
	fn eval(self, stable::Term(scope, clos_env, inner): stable::Term<'c>) -> Option<Term> {
		let (new_scope, new_subst) = stablize(&clos_env, scope.clone(), self, inner.logic.clone())?;
		let stable::Env(subst, z3_env) = clos_env;
		let clos_env = &stable::Env(subst + new_subst, z3_env.extend(&scope));
		let env = &(self + &new_scope);
		let logic = env.eval(clos_env.eval(inner.logic));
		let apps = env.eval(clos_env.eval(inner.apps));
		Some(Sigma(new_scope, Inner { logic, apps }))
	}
}

impl<'c> Eval<stable::Aggr<'c>, Expr> for &Env {
	fn eval(self, agg: stable::Aggr<'c>) -> Expr {
		use shared::Expr::*;
		let op = agg.0.clone();
		let ty = agg.ty();
		let es = Agg(agg).split(&op, self).into_iter().map(|(scp, l, apps, e)| {
			let env = &(self + &scp);
			let inner = Inner { logic: env.eval(l), apps: env.eval(apps) };
			Agg(Aggr(op.clone(), scp, Box::new(inner), Box::new(env.eval(e))))
		});
		Op(op.clone(), es.collect(), ty)
	}
}

impl Unify<partial::UExpr> for Env {
	fn unify(&self, t1: &partial::UExpr, t2: &partial::UExpr) -> bool {
		let t1: UExpr = self.eval(t1.clone());
		let t2: UExpr = self.eval(t2.clone());
		let config = Config::new();
		let z3_ctx = Context::new(&config);
		let ctx = Rc::new(Ctx::new(Solver::new(&z3_ctx)));
		let subst = shared::Expr::vars(0, self.clone()).into_iter().map(Some).collect();
		let z3_subst: Vector<_> = self.iter().map(|ty| ctx.var(ty, "v")).collect();
		let env = &stable::Env(subst, Z3Env::new(ctx.clone(), z3_subst.clone()));
		let t1 = env.eval(t1);
		let t2 = env.eval(t2);
		let t1: UExpr = self.eval(t1);
		let t2: UExpr = self.eval(t2);
		let top = Bool::from_bool(ctx.z3_ctx(), true);
		let uni_env = UnifyEnv(ctx, z3_subst.clone(), z3_subst, top);
		uni_env.unify(&t1, &t2)
	}
}

pub type HOpMap<'c> = HashMap<(String, Vec<Expr>, Relation, Vector<Dynamic<'c>>), Dynamic<'c>>;

pub type RelHOpMap<'c> =
	HashMap<(String, Vec<Expr>, Relation, Vector<Dynamic<'c>>, bool), (String, Vec<DataType>)>;

pub type AggMap<'c> =
	HashMap<(String, Lambda<(Inner, Vec<Expr>)>, Vector<Dynamic<'c>>), Dynamic<'c>>;

#[derive(Clone)]
pub struct Z3Env<'c> {
	pub ctx: Rc<Ctx<'c>>,
	pub subst: Vector<Dynamic<'c>>,
	pub h_ops: Rc<RefCell<HOpMap<'c>>>,
	pub aggs: Rc<RefCell<AggMap<'c>>>,
	pub rel_h_ops: Rc<RefCell<RelHOpMap<'c>>>,
}

impl<'c> Z3Env<'c> {
	#[inline]
	fn bool_true(&self) -> Bool<'c> {
		Bool::from_bool(self.ctx.z3_ctx(), true)
	}

	pub fn equal_expr(&self, _e1: &rel::Expr, _e2: &rel::Expr) -> Bool<'c> {
		self.bool_true()
	}

	pub fn encode_subset(&self, _r1: &rel::Relation, _r2: &rel::Relation) -> Bool<'c> {
		self.bool_true()
	}

	pub fn encode_subattr(&self, _a1: &rel::Expr, _a2: &rel::Expr) -> Bool<'c> {
		self.bool_true()
	}

	pub fn encode_refattr(
		&self,
		_r1: &rel::Relation,
		_a1: &rel::Expr,
		_r2: &rel::Relation,
		_a2: &rel::Expr,
	) -> Bool<'c> {
		self.bool_true()
	}

	pub fn encode_unique(&self, _r: &rel::Relation, _a: &rel::Expr) -> Bool<'c> {
		self.bool_true()
	}

	pub fn encode_notnull(&self, _r: &rel::Relation, _a: &rel::Expr) -> Bool<'c> {
		self.bool_true()
	}

	pub fn encode_fd(
		&self,
		_r: &rel::Relation,
		_x: &Vec<rel::Expr>,
		_y: &Vec<rel::Expr>,
	) -> Bool<'c> {
		self.bool_true()
	}

	pub fn empty(ctx: Rc<Ctx<'c>>) -> Self {
		Self::new(ctx, vector![])
	}

	pub fn new(ctx: Rc<Ctx<'c>>, subst: Vector<Dynamic<'c>>) -> Self {
		Z3Env {
			ctx,
			subst,
			h_ops: Default::default(),
			aggs: Default::default(),
			rel_h_ops: Default::default(),
		}
	}

	pub fn extend(&self, scope: &Vector<DataType>) -> Self {
		let vars = scope.into_iter().map(|ty| self.ctx.var(ty, "v")).collect();
		Z3Env { subst: self.subst.clone() + vars, ..self.clone() }
	}

	pub fn extend_vals(&self, vals: &Vector<Dynamic<'c>>) -> Self {
		Z3Env { subst: &self.subst + vals, ..self.clone() }
	}

	pub fn extend_vars(&self, scope: &Vector<DataType>) -> (Z3Env<'c>, Vector<Dynamic<'c>>) {
		let vars = scope.into_iter().map(|ty| self.ctx.var(ty, "v")).collect();
		(Z3Env { subst: &self.subst + &vars, ..self.clone() }, vars)
	}

	fn exists(&self, vars: &Vector<Dynamic<'c>>, body: &Bool<'c>) -> Bool<'c> {
		let z3_ctx = self.ctx.z3_ctx();
		let bounds = vars.iter().map(|v| v as &dyn Ast).collect_vec();
		exists_const(z3_ctx, &bounds, &[], body)
	}

	fn equal(&self, ty: DataType, a1: &Dynamic<'c>, a2: &Dynamic<'c>) -> Dynamic<'c> {
		use shared::DataType::*;
		let ctx = &self.ctx;
		assert_eq!(a1.get_sort(), a2.get_sort(), "{} and {} have different types.", a1, a2);
		match ty {
			Integer => ctx.int__eq(a1, a2),
			Real => ctx.real__eq(a1, a2),
			Boolean => ctx.bool__eq(a1, a2),
			String => ctx.string__eq(a1, a2),
			Custom(ty) => ctx.generic_eq(ty, a1, a2),
		}
	}

	fn cmp(&self, ty: DataType, cmp: &str, a1: &Dynamic<'c>, a2: &Dynamic<'c>) -> Dynamic<'c> {
		let ctx = &self.ctx;
		use shared::DataType::*;
		assert!(matches!(ty, Integer | Real | String));
		match cmp {
			">" | "GT" => match ty {
				Integer => ctx.int_gt(a1, a2),
				Real => ctx.real_gt(a1, a2),
				_ => ctx.string_gt(a1, a2),
			},
			"<" | "LT" => match ty {
				Integer => ctx.int_lt(a1, a2),
				Real => ctx.real_lt(a1, a2),
				_ => ctx.string_lt(a1, a2),
			},
			">=" | "GE" => match ty {
				Integer => ctx.int_ge(a1, a2),
				Real => ctx.real_ge(a1, a2),
				_ => ctx.string_ge(a1, a2),
			},
			"<=" | "LE" => match ty {
				Integer => ctx.int_le(a1, a2),
				Real => ctx.real_le(a1, a2),
				_ => ctx.string_le(a1, a2),
			},
			_ => unreachable!(),
		}
	}

	// Some x.P
	// exists x. (P[x] == true) => true
	// exists x. (P[x] == null) => null
	// otherwise, forall x. (P[x] == false) => false
	// All x.P
	// exists x. (P[x] == false) => false
	// exists x. (P[x] == null), => null
	// otherwise, forall x. (P[x] == true) => true
	fn quant_cmp(&self, quant: &str, cmp: &str, args: &Vec<Expr>, rel: &Relation) -> Dynamic<'c> {
		let ctx = &self.ctx;
		let z3_ctx = self.ctx.z3_ctx();
		let Lambda(scope, uexpr) = rel.clone();
		assert_eq!(scope.len(), args.len());
		let vals = args.into_iter().map(|a| self.eval(a)).collect_vec();
		let (ref inner_env, vars) = self.extend_vars(&scope);
		let cmp: Dynamic<'c> = match cmp {
			"=" | "EQ" | "<>" | "!=" | "NE" => {
				let cmps = vals
					.iter()
					.zip(&vars)
					.zip(scope)
					.map(|((v, x), ty)| match cmp {
						"=" | "EQ" => self.equal(ty, v, x),
						_ => self.ctx.bool_not(&self.equal(ty, v, x)),
					})
					.collect_vec();
				self.ctx.bool_and_v(&cmps.iter().collect_vec())
			},
			_ if vals.len() == 1 => self.cmp(scope[0].clone(), cmp, &vals[0], &vars[0]),
			_ => todo!(),
		};
		let body = inner_env.eval(&uexpr);
		// r => exists x. v <cmp> x == r /\ |R(x)|
		let p = |res| self.exists(&vars, &Bool::and(z3_ctx, &[&cmp._eq(res), &body]));
		match quant {
			"SOME" | "ANY" => p(&ctx.bool(Some(true))).ite(
				&ctx.bool(Some(true)),
				&p(&ctx.bool(None)).ite(&ctx.bool(None), &ctx.bool(Some(false))),
			),
			_ => p(&ctx.bool(Some(false))).ite(
				&ctx.bool(Some(false)),
				&p(&ctx.bool(None)).ite(&ctx.bool(None), &ctx.bool(Some(true))),
			),
		}
	}
}

impl<'c> Eval<&Logic, Bool<'c>> for &Z3Env<'c> {
	fn eval(self, source: &Logic) -> Bool<'c> {
		use shared::Logic::*;
		let Z3Env { ctx, .. } = self;
		let z3_ctx = ctx.z3_ctx();
		match source {
			Bool(e) => ctx.bool_is_true(&self.eval(e)),
			Eq(e1, e2) => {
				assert_eq!(e1.ty(), e2.ty(), "{} and {} have different types", e1, e2);
				self.eval(e1)._eq(&self.eval(e2))
			},
			Pred(p, args) => {
				let args = args.iter().map(|arg| self.eval(arg)).collect_vec();
				let args = args.iter().collect_vec();
				ctx.app(p, &args, &DataType::Boolean, false).as_bool().unwrap()
			},
			Neg(l) => self.eval(l.as_ref()).not(),
			And(ls) => z3::ast::Bool::and(z3_ctx, &self.eval(ls).iter().collect_vec()),
			Or(ls) => z3::ast::Bool::or(z3_ctx, &self.eval(ls).iter().collect_vec()),
			Squash(u) => self.eval(u.as_ref()),
		}
	}
}

impl<'c> Eval<&UExpr, Bool<'c>> for &Z3Env<'c> {
	fn eval(self, source: &UExpr) -> Bool<'c> {
		let terms = source.iter().map(|t| self.eval(t)).collect_vec();
		Bool::or(self.ctx.z3_ctx(), &terms.iter().collect_vec())
	}
}

impl<'c> Eval<&Term, Bool<'c>> for &Z3Env<'c> {
	fn eval(self, Sigma(scope, body): &Term) -> Bool<'c> {
		let (ref env, vars) = self.extend_vars(scope);
		self.exists(&vars, &env.eval(body))
	}
}

impl<'c> Eval<&Inner, Bool<'c>> for &Z3Env<'c> {
	fn eval(self, source: &Inner) -> Bool<'c> {
		Bool::and(self.ctx.z3_ctx(), &[&self.eval(&source.logic), &self.eval(&source.apps)])
	}
}

impl<'c> Eval<&Vector<Neutral>, Bool<'c>> for &Z3Env<'c> {
	fn eval(self, source: &Vector<Neutral>) -> Bool<'c> {
		let apps: Vector<_> = self.eval(source);
		let z3_ctx = self.ctx.z3_ctx();
		if apps.is_empty() {
			Bool::from_bool(z3_ctx, true)
		} else {
			Bool::and(z3_ctx, &apps.iter().collect_vec())
		}
	}
}

impl<'c> Eval<&Vector<Neutral>, Int<'c>> for &Z3Env<'c> {
	fn eval(self, source: &Vector<Neutral>) -> Int<'c> {
		let apps: Vector<_> = self.eval(source);
		let z3_ctx = self.ctx.z3_ctx();
		if apps.is_empty() {
			Int::from_i64(z3_ctx, 1)
		} else {
			Int::mul(z3_ctx, &apps.iter().collect_vec())
		}
	}
}

fn table_name(head: &Head, env: &Z3Env, squashed: bool, domain: Vec<DataType>) -> String {
	let Z3Env { subst, rel_h_ops, .. } = env;
	match head {
		Head::Var(VL(l)) => format!("r{}!{}", if squashed { "p" } else { "" }, l),
		Head::HOp(op, args, rel) => {
			let len = rel_h_ops.borrow().len();
			let name = format!("rh{}!{}", if squashed { "p" } else { "" }, len);
			rel_h_ops
				.borrow_mut()
				.entry((op.clone(), args.clone(), *rel.clone(), subst.clone(), squashed))
				.or_insert((name, domain))
				.0
				.clone()
		},
	}
}

impl<'c> Eval<&Neutral, Bool<'c>> for &Z3Env<'c> {
	fn eval(self, shared::Neutral(head, args): &Neutral) -> Bool<'c> {
		let domain = args.iter().map(|a| a.ty()).collect();
		let args = args.iter().map(|v| self.eval(v)).collect_vec();
		let args = args.iter().collect_vec();
		self.ctx
			.app(&(table_name(head, self, true, domain) + "p"), &args, &DataType::Boolean, false)
			.as_bool()
			.unwrap()
	}
}

impl<'c> Eval<&Neutral, Int<'c>> for &Z3Env<'c> {
	fn eval(self, shared::Neutral(head, args): &Neutral) -> Int<'c> {
		let domain = args.iter().map(|a| a.ty()).collect();
		let args = args.iter().map(|v| self.eval(v)).collect_vec();
		let args = args.iter().collect_vec();
		self.ctx
			.app(&table_name(head, self, false, domain), &args, &DataType::Integer, false)
			.as_int()
			.unwrap()
	}
}

impl<'c> Eval<&Expr, Dynamic<'c>> for &Z3Env<'c> {
	fn eval(self, source: &Expr) -> Dynamic<'c> {
		use DataType::*;
		let Z3Env { ctx, subst, h_ops, aggs, .. } = self;
		let parse = |ctx: &Ctx<'c>, input: &str, ty: &DataType| -> anyhow::Result<Dynamic<'c>> {
			if input.to_lowercase() == "null" {
				let null = match ty {
					Integer => ctx.int_none(),
					Real => ctx.real_none(),
					Boolean => ctx.bool_none(),
					String => ctx.string_none(),
					_ => bail!("unsupported type {:?} for null", ty),
				};
				return Ok(null);
			}
			let z3_ctx = ctx.z3_ctx();
			Ok(match ty {
				Integer => ctx.int_some(Int::from_i64(z3_ctx, input.parse()?)),
				Real => {
					let r: f32 = input.parse()?;
					let r = num::rational::Ratio::from_float(r).unwrap();
					ctx.real_some(Re::from_real(
						z3_ctx,
						r.numer().to_i32().unwrap(),
						r.denom().to_i32().unwrap(),
					))
				},
				Boolean => ctx.bool(Some(input.to_lowercase().parse()?)),
				String => ctx.string_some(Str::from_str(z3_ctx, input).unwrap()),
				_ => bail!("unsupported type {:?} for constant {}", ty, input),
			})
		};
		match source {
			Expr::Var(VL(l), _) => subst[*l].clone(),
			Expr::Log(l) => ctx.bool_some(self.eval(l.as_ref())),
			Expr::Op(op, args, ty)
				if args.is_empty()
					&& let Ok(exp) = parse(ctx.as_ref(), op, ty) =>
			{
				exp
			},
			Expr::Op(op, expr_args, ty) => {
				let args = expr_args.iter().map(|a| self.eval(a)).collect_vec();
				let args = args.iter().collect_vec();
				match op.as_str() {
					op if num_op(op) && ty == &Integer => match op {
						"+" | "PLUS" | "UNARY PLUS" => ctx.int_add_v(&args),
						"-" | "MINUS" | "UNARY MINUS" => ctx.int_sub_v(&args),
						"*" | "MULT" => ctx.int_mul_v(&args),
						"/" | "DIV" => ctx.int_div(args[0], args[1]),
						"%" => ctx.int_modulo(args[0], args[1]),
						// "POWER" => ctx.int_power(args[0], args[1]),
						_ => unreachable!(),
					},
					op if num_op(op) && ty == &Real => match op {
						"+" | "PLUS" | "UNARY PLUS" => ctx.real_add_v(&args),
						"-" | "MINUS" | "UNARY MINUS" => ctx.real_sub_v(&args),
						"*" | "MULT" => ctx.real_mul_v(&args),
						"/" | "DIV" => ctx.real_div(args[0], args[1]),
						// "POWER" => ctx.real_power(args[0], args[1]),
						_ => unreachable!(),
					},
					cmp @ (">" | "GT" | "<" | "LT" | ">=" | "GE" | "<=" | "LE")
						if matches!(expr_args[0].ty(), Integer | Real | String) =>
					{
						self.cmp(expr_args[0].ty(), cmp, args[0], args[1])
					},
					"=" | "EQ" => self.equal(expr_args[0].ty(), args[0], args[1]),
					"<>" | "!=" | "NE" => {
						self.ctx.bool_not(&self.equal(expr_args[0].ty(), args[0], args[1]))
					},
					"NOT" if args.len() == 1 => ctx.bool_not(args[0]),
					"AND" => ctx.bool_and_v(&args),
					"OR" => ctx.bool_or_v(&args),
					"CASE" if args.len() % 2 == 1 => {
						let (chunks, remainder) = args.as_chunks();
						chunks.iter().rfold(remainder[0].clone(), |rem, [cond, body]| {
							ctx.bool_is_true(cond).ite(body, &rem)
						})
					},
					"CASE" if args.len() >= 2 && args.len() % 2 == 0 => {
						let input = args[0].clone();
						let (chunks, remainder) = args[1..].as_chunks();
						chunks.iter().rfold(remainder[0].clone(), |rem, [val, body]| {
							input._eq(val).ite(body, &rem)
						})
					},
					"CAST" if ty == &expr_args[0].ty() => args[0].clone(),
					"CAST" if ty == &Real && expr_args[0].ty() == Integer => {
						ctx.int_to_real(args[0])
					},
					"CAST"
						if let Expr::Op(op, args, _) = &expr_args[0]
							&& args.is_empty() && let Ok(exp) = parse(ctx.as_ref(), op, ty) =>
					{
						exp
					},
					"COUNT" | "SUM" | "MIN" | "MAX" => {
						if args.len() == 1 {
							args[0].clone()
						} else {
							ctx.app(&format!("f{}!{}", args.len(), op), &args, ty, true)
						}
					},
					op => ctx.app(&format!("f!{}", op.replace('\'', "\"")), &args, ty, true),
				}
			},
			// TODO: Support inequality between multiple values.
			Expr::HOp(f, args, rel, DataType::Boolean)
				if let Some((cmp, quant)) = f.split_whitespace().collect_tuple()
					&& num_cmp(cmp) && args.len() == 1
					&& matches!(quant, "SOME" | "ANY" | "ALL") =>
			{
				self.quant_cmp(quant, cmp, args, rel)
			},
			Expr::HOp(f, args, rel, DataType::Boolean)
				if let Some((cmp, quant)) = f.split_whitespace().collect_tuple()
					&& matches!(cmp, "=" | "EQ" | "<>" | "!=" | "NE")
					&& matches!(quant, "SOME" | "ANY" | "ALL") =>
			{
				self.quant_cmp(quant, cmp, args, rel)
			},
			Expr::HOp(f, args, rel, DataType::Boolean) if f == "IN" => {
				self.quant_cmp("SOME", "=", args, rel)
			},
			Expr::HOp(f, args, rel, ty) => h_ops
				.borrow_mut()
				.entry((f.clone(), args.clone(), *rel.clone(), subst.clone()))
				.or_insert_with(|| self.ctx.var(ty, "h"))
				.clone(),
			Expr::Agg(agg) => {
				let Aggr(f, scope, inner, expr) = agg;
				aggs.borrow_mut()
					.entry((
						f.clone(),
						Lambda(scope.clone(), (*inner.clone(), vec![*expr.clone()])),
						subst.clone(),
					))
					.or_insert_with(|| self.ctx.var(&expr.ty(), "h"))
					.clone()
			},
		}
	}
}

impl<'c> Eval<&Vec<constraint::Constraint>, Bool<'c>> for &Z3Env<'c> {
	fn eval(self, constraints: &Vec<constraint::Constraint>) -> Bool<'c> {
		use constraint::Constraint::*;
		let z3_ctx = self.ctx.z3_ctx();

		let encoded: Vec<Bool<'c>> = constraints
			.iter()
			.map(|c| match c {
				RelEq { r1, r2 } => {
					let l2r = self.encode_subset(r1, r2);
					let r2l = self.encode_subset(r2, r1);
					Bool::and(z3_ctx, &[&l2r, &r2l])
				}
				AttrsEq { a1, a2 } => {
					self.equal_expr(a1, a2)
				},
				PredEq { p1, p2 } => {
					self.equal_expr(p1, p2)
				},
				SubAttr { a1, a2 } => {
					self.encode_subattr(a1, a2)
				},
				RefAttr { r1, a1, r2, a2 } => {
					self.encode_refattr(r1, a1, r2, a2)
				},
				Unique { r, a } => {
					self.encode_unique(r, a)
				},
				NotNull { r, a } => {
					self.encode_notnull(r, a)
				},
				FD { r, x, y } => {
					self.encode_fd(r, x, y)
				},
				Const { a, r, c } => {
					self.equal_expr(a, c)
				},
				Subset { r1, r2 } => {
					self.encode_subset(r1, r2)
				},
			})
			.collect();

		if encoded.is_empty() {
			Bool::from_bool(z3_ctx, true)
		} else {
			Bool::and(z3_ctx, &encoded.iter().collect::<Vec<_>>())
		}
	}
}
```

"""pipeline/relation.rs"""
```rust
use std::iter::once;
use std::ops::{Mul, Not};

use imbl::{vector, Vector};
use itertools::{Either, Itertools};
use serde::{Deserialize, Serialize};

use super::syntax::Aggr;
use crate::pipeline::shared::{DataType, Eval, Head, Lambda, Neutral, Schema, Typed, VL};
use crate::pipeline::syntax::{Logic, UExpr};
use crate::pipeline::{shared, syntax};

#[derive(Copy, Clone)]
pub struct Env<'e>(pub &'e [Schema], pub &'e Vector<syntax::Expr>, pub usize);

fn vars(level: usize, types: Vector<DataType>) -> Vector<syntax::Expr> {
	types.into_iter().enumerate().map(|(i, ty)| syntax::Expr::Var(VL(level + i), ty)).collect()
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum Relation {
	Singleton,
	Scan(VL),
	Filter {
		condition: Expr,
		source: Box<Relation>,
	},
	Project {
		#[serde(alias = "target")]
		columns: Vec<Expr>,
		source: Box<Relation>,
	},
	Join {
		condition: Expr,
		left: Box<Relation>,
		right: Box<Relation>,
		kind: JoinKind,
	},
	Correlate {
		// TODO: Add condition?
		left: Box<Relation>,
		right: Box<Relation>,
		kind: JoinKind,
	},
	Union(Vec<Relation>),
	Intersect(Vec<Relation>),
	Except(Box<Relation>, Box<Relation>),
	Distinct(Box<Relation>),
	Values {
		schema: Vec<DataType>,
		content: Vec<Vec<Expr>>,
	},
	Aggregate {
		#[serde(alias = "function")]
		columns: Vec<AggCall>,
		source: Box<Relation>,
	},
	Group {
		keys: Vec<Expr>,
		#[serde(alias = "function")]
		columns: Vec<AggCall>,
		source: Box<Relation>,
	},
	Sort {
		collation: Vec<(usize, DataType, String)>,
		offset: Option<Expr>,
		limit: Option<Expr>,
		source: Box<Relation>,
	},
}

impl Relation {
	fn scope(&self, schemas: &[Schema]) -> Vector<DataType> {
		use JoinKind::*;
		use Relation::*;
		match self {
			Singleton => Vector::new(),
			Scan(table) => schemas[table.0].types.clone().into(),
			Filter { source, .. } => source.scope(schemas),
			Project { columns, .. } => columns.iter().map(Expr::ty).collect(),
			Aggregate { columns, .. } => columns.iter().map(|agg| agg.ty.clone()).collect(),
			Group { columns, keys: key, .. } => {
				key.iter().map(Expr::ty).chain(columns.iter().map(|agg| agg.ty.clone())).collect()
			},
			Join { left, kind: Semi | Anti, .. } | Correlate { left, kind: Semi | Anti, .. } => {
				left.scope(schemas)
			},
			Join { left, right, .. } | Correlate { left, right, .. } => {
				left.scope(schemas) + right.scope(schemas)
			},
			Union(rels) | Intersect(rels) => rels[0].scope(schemas),
			Except(rel1, _) => rel1.scope(schemas),
			Distinct(rel) => rel.scope(schemas),
			Values { schema, .. } => schema.clone().into(),
			Sort { source, .. } => source.scope(schemas),
		}
	}

	pub fn complete(&self) -> bool {
		use Relation::*;
		match self {
			Singleton | Scan(_) => true,
			Filter { condition, source } => condition.complete() && source.complete(),
			Project { columns, source } => columns.iter().all(Expr::complete) && source.complete(),
			Join { kind: JoinKind::Inner, condition, left, right} => condition.complete() && left.complete() && right.complete(),
			Union(rels) => rels.iter().all(Relation::complete),
			Values { content, .. } => content.iter().flatten().all(Expr::complete),
			_ => false
		}
	}
}

impl Eval<Relation, syntax::Relation> for Env<'_> {
	fn eval(self, source: Relation) -> syntax::Relation {
		use syntax::UExpr::*;
		use JoinKind::*;
		use Relation::*;
		let Env(schemas, subst, lvl) = self;
		let scope = source.scope(schemas);
		match source {
			Singleton => Lambda(vector![], UExpr::one()),
			Scan(VL(t)) => {
				let vars = vars(lvl, scope.clone());
				let schema = &schemas[t];
				let conds = schema.guaranteed.iter().map(|cond| {
					UExpr::pred(Env(schemas, &vars, lvl + scope.len()).eval(cond.clone()))
				});
				let constraints =
					schema.nullabilities.iter().zip(vars.clone()).map(|(nullable, v)| {
						if !*nullable {
							UExpr::pred(!v.is_null())
						} else {
							UExpr::one()
						}
					});
				let app = if schema.primary.is_empty() {
					let app = UExpr::Neu(Neutral(Head::Var(VL(t)), vars.clone()));
					app.clone() * UExpr::squash(app)
				} else {
					let key_constraints =
						schema.primary.iter().enumerate().flat_map(|(j, cols)| {
							use shared::Expr::*;
							let (keys, args): (Vec<_>, Vec<_>) =
								vars.iter().cloned().enumerate().partition_map(|(i, v)| {
									if cols.contains(&i) {
										Either::Left(v)
									} else {
										Either::Right(v)
									}
								});
							let pk = Logic::Pred(format!("rpk!{}-{}", t, j), keys.clone());
							let pa = args.into_iter().enumerate().map(move |(i, arg)| {
								let f =
									Op(format!("rpn!{}-{}-{}", t, i, j), keys.clone(), arg.ty());
								Logic::Eq(arg, f)
							});
							pa.chain(once(pk))
						});
					UExpr::pred(key_constraints.product())
				};
				Lambda(scope.clone(), app * Mul(constraints.collect()) * Mul(conds.collect()))
			},
			// Filter R(x, y) by P[x, y]
			// λ x, y. [P[x, y]] × R(x, y)
			Filter { condition, source } => {
				let vars = vars(lvl, scope.clone());
				let body_lvl = lvl + scope.len();
				let cond_subst = subst + &vars;
				let condition = UExpr::pred(Env(schemas, &cond_subst, body_lvl).eval(condition));
				let source = Env(schemas, subst, body_lvl).eval(*source);
				Lambda(scope, condition * UExpr::app(source, vars))
			},
			// Project f[x, y] from R(x, y)
			// λ a. ∑ x, y. [a = f[x, y]] × R(x, y)
			Project { columns, source } => {
				let inner_scope = source.scope(schemas);
				let inner_vars = vars(lvl + scope.len(), inner_scope.clone());
				let inner_lvl = lvl + scope.len() + inner_scope.len();
				let source = Env(schemas, subst, inner_lvl).eval(*source);
				let cols_subst = subst + &inner_vars;
				let cols_env = Env(schemas, &cols_subst, inner_lvl);
				let matches = vars(lvl, scope.clone())
					.into_iter()
					.zip(columns)
					.map(|(var, col)| Logic::Eq(var, cols_env.eval(col)));
				let app = UExpr::app(source, inner_vars);
				Lambda(scope, UExpr::sum(inner_scope, UExpr::pred(matches.product()) * app))
			},
			// R(x) semi join S(y) on P[x, y]
			// λ x. R(x) × ‖∑ y. [P[x, y]] × S(y)‖
			Join { condition, left, right, kind: kind @ (Semi | Anti) } => {
				let left_vars = vars(lvl, scope.clone());
				let body_lvl = lvl + scope.len();
				let inner_scope = right.scope(schemas);
				let inner_lvl = body_lvl + inner_scope.len();
				let right_vars = vars(body_lvl, inner_scope.clone());
				let cond_subst = subst + &(&left_vars + &right_vars);
				let cond = UExpr::pred(Env(schemas, &cond_subst, inner_lvl).eval(condition));
				let right_body =
					UExpr::app(Env(schemas, subst, inner_lvl).eval(*right), right_vars);
				let left_body = UExpr::app(Env(schemas, subst, body_lvl).eval(*left), left_vars);
				let wrapper = match kind {
					Semi => UExpr::squash,
					Anti => UExpr::not,
					_ => unreachable!(),
				};
				Lambda(scope, left_body * wrapper(UExpr::sum(inner_scope, cond * right_body)))
			},
			// R(x) inner join S(y) on P[x, y]
			// λ x, y. [P[x, y]] × R(x) × S(y)
			// R(x) full join S(y) on P[x, y]
			// λ x, y. [P[x, y]] × R(x) × S(y)
			//        + ¬(∑ x'. P[x', y] × R(x')) × Null(x) × S(y)
			//        + ¬(∑ y'. P[x, y'] × S(y')) × Null(y) × R(x)
			Join { condition, left, right, kind } => {
				let left_scope = left.scope(schemas);
				let right_scope = right.scope(schemas);
				let right_vars = &vars(lvl + left_scope.len(), right_scope);
				let left_vars = &vars(lvl, left_scope);
				let body_lvl = lvl + scope.len();
				let body_env = Env(schemas, subst, body_lvl);
				let left_body = UExpr::app(body_env.eval(*left.clone()), left_vars.clone());
				let right_body = UExpr::app(body_env.eval(*right.clone()), right_vars.clone());
				let cond_subst = subst + &(left_vars + right_vars);
				let cond_env = Env(schemas, &cond_subst, body_lvl);
				let matching = UExpr::pred(cond_env.eval(condition.clone()))
					* left_body.clone() * right_body.clone();
				let miss = |miss_left| {
					let missing = *if miss_left { left.clone() } else { right.clone() };
					let inner_scope = missing.scope(schemas);
					let inner_vars = vars(body_lvl, inner_scope.clone());
					let inner_lvl = body_lvl + inner_scope.len();
					let inner_cond_vars =
						if miss_left { &inner_vars + right_vars } else { left_vars + &inner_vars };
					let inner_cond_subst = subst + &inner_cond_vars;
					let inner_cond = UExpr::pred(
						Env(schemas, &inner_cond_subst, inner_lvl).eval(condition.clone()),
					);
					let missing = Env(schemas, subst, inner_lvl).eval(missing);
					let inner_body = inner_cond * UExpr::app(missing, inner_vars);
					let other_body = if miss_left { right_body.clone() } else { left_body.clone() };
					if miss_left { left_vars } else { right_vars }
						.iter()
						.map(|v| UExpr::pred(v.clone().is_null()))
						.fold(other_body * !UExpr::sum(inner_scope, inner_body), UExpr::mul)
				};
				match kind {
					Inner => Lambda(scope, matching),
					Left => Lambda(scope, matching + miss(false)),
					Right => Lambda(scope, matching + miss(true)),
					Full => Lambda(scope, matching + miss(true) + miss(false)),
					_ => unreachable!(),
				}
			},
			// R(x) correlated join S[x](y)
			// λx, y. R(x) × S[x](y)
			// R(x) left correlated join S[x](y)
			// λx, y. R(x) × S[x](y) + R(x) × Null(y) × ¬(∑ y'. S[x](y'))
			// R(x) semi correlated join S[x](y)
			// λx. R(x) × ‖∑ y. S[x](y)‖
			Correlate { kind, left, right } => {
				let left_scope = left.scope(schemas);
				let right_scope = right.scope(schemas);
				let left_vars = vars(lvl, left_scope.clone());
				let right_subst = subst + &left_vars;
				let body_lvl = lvl + scope.len();
				let inner = |positive| {
					let inner_app = UExpr::app(
						Env(schemas, &right_subst, body_lvl + right_scope.len())
							.eval(*right.clone()),
						vars(body_lvl, right_scope.clone()),
					);
					let wrapper = if positive { UExpr::squash } else { UExpr::not };
					wrapper(UExpr::sum(right_scope.clone(), inner_app))
				};
				let left_app = UExpr::app(Env(schemas, subst, body_lvl).eval(*left), left_vars);
				let right_vars = vars(lvl + left_scope.len(), right_scope.clone());
				let right_app = UExpr::app(
					Env(schemas, &right_subst, body_lvl).eval(*right.clone()),
					right_vars.clone(),
				);
				match kind {
					Inner => Lambda(scope, left_app * right_app),
					Left => {
						let nulls = right_vars.iter().map(|v| v.clone().is_null());
						Lambda(
							scope,
							left_app.clone() * right_app
								+ left_app * UExpr::pred(nulls.product()) * inner(false),
						)
					},
					Semi => Lambda(scope, left_app * inner(true)),
					Anti => Lambda(scope, left_app * inner(false)),
					_ => panic!("Unsupported join type in correlated join."),
				}
			},
			// R(x) union all S(y)
			// λx. R(x) + S(x)
			Union(sources) => {
				let body_lvl = lvl + scope.len();
				let vars = vars(lvl, scope.clone());
				let sum = sources
					.into_iter()
					.map(|source| {
						UExpr::app(Env(schemas, subst, body_lvl).eval(source), vars.clone())
					})
					.collect();
				Lambda(scope, Add(sum))
			},
			// R(x) intersect S(y)
			// λx. ‖R(x) × S(x)‖
			Intersect(sources) => {
				let body_lvl = lvl + scope.len();
				let vars = vars(lvl, scope.clone());
				let prod = sources
					.into_iter()
					.map(|source| {
						UExpr::app(Env(schemas, subst, body_lvl).eval(source), vars.clone())
					})
					.collect();
				Lambda(scope, UExpr::squash(Mul(prod)))
			},
			// R(x) except S(y)
			// λx. ‖R(x) × ¬S(x)‖
			Except(left, right) => {
				let body_lvl = lvl + scope.len();
				let vars = vars(lvl, scope.clone());
				let left = Env(schemas, subst, body_lvl).eval(*left);
				let right = Env(schemas, subst, body_lvl).eval(*right);
				Lambda(
					scope,
					UExpr::squash(UExpr::app(left, vars.clone()) * !UExpr::app(right, vars)),
				)
			},
			// Distinct R(x)
			// λx. ‖R(x)‖
			Distinct(source) => {
				let source = Env(schemas, subst, lvl + scope.len()).eval(*source);
				Lambda(scope.clone(), UExpr::squash(UExpr::app(source, vars(lvl, scope))))
			},
			// Values ((a1, b1), (a2, b2), (a3, b3))
			// λx, y. [x = a1] × [y = b1] + [x = a2] × [y = b2] + [x = a3] × [y = b3]
			Values { schema: _, content } => {
				let vars = vars(lvl, scope.clone());
				let env = Env(schemas, subst, lvl + scope.len());
				let rows = content.into_iter().map(|row| {
					let cols = vars
						.iter()
						.zip(row)
						.map(|(v, e)| UExpr::pred(Logic::Eq(v.clone(), env.eval(e))));
					Mul(cols.collect())
				});
				Lambda(scope, Add(rows.collect()))
			},
			// Agg1(f[x, y]), Agg2(g[x, y]) on R(x, y)
			// λa, b. [a = Agg1(λc. ∑x, y. [c = f[x, y]] × R(x, y))]
			//        × [b = Agg2(λc. ∑x, y. [c = g[x, y]] × R(x, y))]
			Aggregate { columns, source } => {
				let vars = vars(lvl, scope.clone());
				let env = Env(schemas, subst, lvl + scope.len());
				let cols = vars
					.into_iter()
					.zip(columns)
					.map(|(v, agg)| UExpr::pred(Logic::Eq(v, env.eval((agg, *source.clone())))));
				Lambda(scope, Mul(cols.collect()))
			},
			// Agg(f[x, y]) on R(x, y) group by g[x, y]
			// λk, a. ‖∑x, y. [k = g[x, y]] × R(x, y)‖ × [a = Agg(λa'. ∑x, y. [a' = f[x, y]] × [k = g[x, y]] × R(x, y))]
			Group { keys: key, columns, source } => {
				let source_scope = source.scope(schemas);
				let (key_vars, agg_vars) = vars(lvl, scope.clone()).split_at(key.len());
				let grouped = |lvl, vars| {
					let key_subst = subst + &vars;
					let key_env = Env(schemas, &key_subst, lvl);
					let matches = key_vars
						.iter()
						.zip(key.clone())
						.map(|(v, k)| Logic::Eq(v.clone(), key_env.eval(k)));
					let app = UExpr::app(Env(schemas, subst, lvl).eval(source.clone()), vars);
					UExpr::pred(matches.product()) * app
				};
				let body_lvl = lvl + scope.len();
				let source_vars = vars(body_lvl, source_scope.clone());
				let agged = |agg: AggCall| {
					if agg.op == "LITERAL_AGG" && agg.args.len() == 1 {
						return self.eval(agg.args[0].clone());
					}
					let inner_scope: Vector<_> = agg.args.iter().map(|e| e.ty()).collect();
					let inner_lvl = body_lvl + inner_scope.len();
					let source_vars = vars(inner_lvl, source_scope.clone());
					let arg_subst = subst + &source_vars;
					let arg_env = Env(schemas, &arg_subst, inner_lvl + source_scope.len());
					let inner_vars = vars(body_lvl, inner_scope.clone());
					let matches = inner_vars
						.iter()
						.zip(agg.args)
						.map(|(v, arg)| Logic::Eq(v.clone(), arg_env.eval(arg)));
					let body = UExpr::sum(
						source_scope.clone(),
						UExpr::pred(matches.product())
							* grouped(inner_lvl + source_scope.len(), source_vars),
					);
					let body = if agg.ignore_nulls {
						let conditions = inner_vars.iter().map(|v| !v.clone().is_null());
						UExpr::pred(conditions.product()) * body
					} else {
						body
					};
					let body = if agg.distinct { UExpr::squash(body) } else { body };
					use shared::Expr::{Agg, HOp};
					match agg.op.as_str() {
						"COUNT" => Agg(Aggr(agg.op, inner_scope, body, Box::new(1u32.into()))),
						_ if inner_scope.len() == 1 && inner_scope[0] == agg.ty => {
							Agg(Aggr(agg.op, inner_scope, body, inner_vars[0].clone().into()))
						},
						_ => HOp(agg.op, vec![], Lambda(inner_scope, body).into(), agg.ty),
					}
				};
				let aggs =
					agg_vars.into_iter().zip(columns).map(|(v, agg)| Logic::Eq(v, agged(agg)));
				let left = UExpr::squash(UExpr::sum(
					source_scope.clone(),
					grouped(body_lvl + source_scope.len(), source_vars),
				));
				Lambda(scope, left * UExpr::pred(aggs.product()))
			},
			Sort { mut collation, offset, limit, source } => {
				// TODO: Better way to handle multiple sort columns.
				let vars = vars(lvl, scope.clone());
				let env = Env(schemas, subst, lvl + scope.len());
				let head = if let Some((col, _, ord)) = collation.pop() {
					let body = env.eval(Sort { collation, offset, limit, source }.into());
					Head::HOp("sort".to_string(), vec![col.into(), ord.into()], body)
				} else {
					let source = env.eval(source);
					let offset = offset.map(|n| env.eval(n)).unwrap_or(0u32.into());
					if let Some(count) = limit {
						Head::HOp("limit".to_string(), vec![env.eval(count), offset], source)
					} else {
						Head::HOp("offset".to_string(), vec![offset], source)
					}
				};
				Lambda(scope, Neu(Neutral(head, vars)))
			},
		}
	}
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "UPPERCASE")]
pub enum JoinKind {
	Inner,
	Left,
	Right,
	Full,
	Semi,
	Anti,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct AggCall {
	#[serde(alias = "operator")]
	op: String,
	#[serde(alias = "operand")]
	args: Vec<Expr>,
	#[serde(default = "default_distinct")]
	distinct: bool,
	#[serde(default = "default_ignore_nulls")]
	ignore_nulls: bool,
	#[serde(alias = "type")]
	ty: DataType,
}

fn default_distinct() -> bool {
	false
}

fn default_ignore_nulls() -> bool {
	true
}

impl Eval<(AggCall, Relation), syntax::Expr> for Env<'_> {
	fn eval(self, (agg, rel): (AggCall, Relation)) -> syntax::Expr {
		let args = agg.args;
		let source = match agg.op.as_str() {
			"COUNT" if args.is_empty() => rel,
			_ => Relation::Project { columns: args, source: rel.into() },
		};
		let Env(_, _, lvl) = self;
		let Lambda(scope, body) = self.eval(source);
		let body = if agg.ignore_nulls {
			let conditions = vars(lvl, scope.clone()).into_iter().map(|v| !v.is_null());
			UExpr::pred(conditions.product()) * body
		} else {
			body
		};
		let body = if agg.distinct { UExpr::squash(body) } else { body };
		// TODO: Handle various agg calls.
		match agg.op.as_str() {
			"COUNT" => syntax::Expr::Agg(Aggr(agg.op, scope, body, Box::new(1u32.into()))),
			_ if scope.len() == 1 && scope[0] == agg.ty => {
				let var = vars(lvl, scope.clone())[0].clone();
				syntax::Expr::Agg(Aggr(agg.op, scope, body, var.into()))
			},
			_ => syntax::Expr::HOp(agg.op, vec![], Lambda(scope, body).into(), agg.ty),
		}
	}
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[serde(untagged)]
pub enum Expr {
	Col {
		column: VL,
		#[serde(alias = "type")]
		ty: DataType,
	},
	Op {
		#[serde(alias = "operator")]
		op: String,
		#[serde(alias = "operand")]
		args: Vec<Expr>,
		#[serde(alias = "type")]
		ty: DataType,
		#[serde(alias = "query")]
		rel: Option<Box<Relation>>,
	},
}

impl Expr {
	fn ty(&self) -> DataType {
		match self {
			Expr::Col { ty, .. } => ty,
			Expr::Op { ty, .. } => ty,
		}
		.clone()
	}

	fn into_real(self) -> Expr {
		if self.ty() == DataType::Real {
			self
		} else {
			Expr::Op { op: "CAST".to_string(), args: vec![self], ty: DataType::Real, rel: None }
		}
	}

	fn complete(&self) -> bool {
		match self {
			Expr::Op { rel: Some(_), .. } => false,
			Expr::Col { .. } => true,
			Expr::Op { args, rel: None, .. } => args.iter().all(Expr::complete)
		}
	}
}

pub fn num_op(op: &str) -> bool {
	matches!(
		op,
		"+" | "PLUS" | "UNARY PLUS" | "-" | "MINUS" | "UNARY MINUS" | "*" | "MULT" | "/" | "DIV"
	)
}

pub fn num_cmp(op: &str) -> bool {
	matches!(op, |">"| "GT"
		| "<" | "LT"
		| ">=" | "GE"
		| "<=" | "LE"
		| "=" | "EQ"
		| "<>" | "!="
		| "NE")
}

impl Eval<Expr, syntax::Expr> for Env<'_> {
	fn eval(self, source: Expr) -> syntax::Expr {
		use shared::Expr::*;
		match source {
			e if let Some(l) = self.eval_logic(&e) => Log(l.into()),
			Expr::Col { column, ty: _ } => self.1[column.0].clone(),
			Expr::Op { op, args, ty, rel: None } => {
				let cast = (num_op(&op) && ty == DataType::Real)
					|| (num_cmp(&op) && args.iter().any(|e| e.ty() == DataType::Real));
				let args =
					if cast { args.into_iter().map(Expr::into_real).collect() } else { args };
				Op(op, self.eval(args), ty)
			},
			Expr::Op { op, args, rel: Some(rel), ty } => {
				HOp(op, self.eval(args), self.eval(*rel).into(), ty)
			},
		}
	}
}

impl Env<'_> {
	fn eval_logic(self, source: &Expr) -> Option<Logic> {
		match source {
			Expr::Op { op, args, ty: DataType::Boolean, rel: None } => {
				match op.to_uppercase().as_str() {
					"TRUE" => Some(Logic::tt()),
					"FALSE" => Some(Logic::ff()),
					"<=>" | "IS" | "IS NOT DISTINCT FROM" => {
						Some(Logic::Eq(self.eval(args[0].clone()), self.eval(args[1].clone())))
					},
					"IS NOT" | "IS DISTINCT FROM" => {
						Some(!Logic::Eq(self.eval(args[0].clone()), self.eval(args[1].clone())))
					},
					"IS NULL" => {
						let e: syntax::Expr = self.eval(args[0].clone());
						Some(e.is_null())
					},
					"IS NOT NULL" => {
						let e: syntax::Expr = self.eval(args[0].clone());
						Some(!e.is_null())
					},
					"IS TRUE" => Some(Logic::Bool(self.eval(args[0].clone()))),
					"IS NOT TRUE" => Some(!Logic::Bool(self.eval(args[0].clone()))),
					_ => None,
				}
			},
			Expr::Op { op, args: _, rel: Some(rel), ty: DataType::Boolean } => match op.as_str() {
				"EXISTS" => {
					let Env(schemas, subst, lvl) = self;
					let scope = rel.scope(schemas);
					let rel = Env(schemas, subst, lvl + scope.len()).eval(*rel.clone());
					let vars = vars(lvl, scope.clone());
					Some(Logic::squash(UExpr::sum(scope, UExpr::app(rel, vars))))
				},
				_ => None,
			},
			_ => None,
		}
	}
}

impl Eval<Expr, Logic> for Env<'_> {
	fn eval(self, source: Expr) -> Logic {
		assert_eq!(source.ty(), DataType::Boolean, "wrong type for predicate");
		match source.clone() {
			e if let Some(l) = self.eval_logic(&e) => l,
			Expr::Op { op, args, .. } => match op.to_uppercase().as_str() {
				"AND" => args.into_iter().map(|arg| self.eval(arg)).product(),
				"OR" => args.into_iter().map(|arg| self.eval(arg)).sum(),
				_ => Logic::Bool(self.eval(source)),
			},
			Expr::Col { .. } => Logic::Bool(self.eval(source)),
		}
	}
}
```

"""pipeline/unify.rs"""
```rust
use std::io::{Read, Write};
use std::process::{Command, Stdio};
use std::rc::Rc;
use std::time::Instant;

use crossbeam::sync::UnparkReason;
use imbl::Vector;
use itertools::Itertools;
use z3::ast::{Ast, Bool, Dynamic, Int};

use super::normal::{Inner, Term};
use super::shared::{Ctx, Lambda, Sigma};
use crate::pipeline::normal::{Expr, UExpr, Z3Env};
use crate::pipeline::shared::{DataType, Eval};

pub trait Unify<T> {
	fn unify(&self, t1: &T, t2: &T) -> bool;
}

#[derive(Clone)]
pub struct UnifyEnv<'c>(pub Rc<Ctx<'c>>, pub Vector<Dynamic<'c>>, pub Vector<Dynamic<'c>>, pub Bool<'c>);

impl<'c> UnifyEnv<'c> {
	#[inline]
	fn phi(&self) -> &Bool<'c> { &self.3 }
}

impl UnifyEnv<'_> {
	fn envs(&self) -> (Z3Env, Z3Env) {
		let UnifyEnv(ctx, subst1, subst2, _) = self;
		let z3_env = Z3Env::empty(ctx.clone());
		let env1 = z3_env.extend_vals(subst1);
		let env2 = z3_env.extend_vals(subst2);
		(env1, env2)
	}
}

impl<'c, T> Unify<Lambda<T>> for UnifyEnv<'c>
where UnifyEnv<'c>: Unify<T>
{
	fn unify(&self, t1: &Lambda<T>, t2: &Lambda<T>) -> bool {
		let (Lambda(scp1, body1), Lambda(scp2, body2)) = (t1, t2);
		if scp1 != scp2 {
			return false;
		}
		let UnifyEnv(ctx, subst1, subst2, _) = self;
		let vars = &scp1.iter().map(|ty| ctx.var(ty, "v")).collect();
		let env = UnifyEnv(ctx.clone(), subst1 + vars, subst2 + vars, self.phi().clone());
		env.unify(body1, body2)
	}
}

impl<'c, A, B> Unify<(A, B)> for UnifyEnv<'c>
where UnifyEnv<'c>: Unify<A> + Unify<B>
{
	fn unify(&self, (a1, b1): &(A, B), (a2, b2): &(A, B)) -> bool {
		self.unify(a1, a2) && self.unify(b1, b2)
	}
}

impl<'c> Unify<UExpr> for UnifyEnv<'c> {
	fn unify(&self, u1: &UExpr, u2: &UExpr) -> bool {
		let mut terms2 = u2.0.clone();
		u1.0.len() == u2.0.len()
			&& u1.iter().all(|t1| {
				(0..terms2.len())
					.any(|i| self.unify(t1, &terms2[i]).then(|| terms2.remove(i)).is_some())
			})
	}
}

impl<'c> Unify<Vec<Expr>> for UnifyEnv<'c> {
	fn unify(&self, es1: &Vec<Expr>, es2: &Vec<Expr>) -> bool {
		let UnifyEnv(ctx, _, _, _) = self;
		es1.len() == es2.len() && {
			let (ref env1, ref env2) = self.envs();
			let expr_eqs =
				es1.iter().zip(es2).map(|(e1, e2)| env1.eval(e1)._eq(&env2.eval(e2))).collect_vec();
			let eq = Bool::and(ctx.z3_ctx(), &expr_eqs.iter().collect_vec());
			let h_ops_eq = env1.extract_equiv();
			// let phi = self.phi();
			let antecedent = Bool::and(ctx.z3_ctx(), &[self.phi(), &h_ops_eq]);
			
			// println!("constraints:\n{}\n", self.phi());
			// println!("antecedent:\n{}\n", antecedent);
			// println!("goal(eq):\n{}\n", eq);

			let unify_start = Instant::now();
			// let (res, timed_out) = smt(&ctx.solver, h_ops_eq.implies(&eq));
			let (res, timed_out) = smt(&ctx.solver, antecedent.implies(&eq));
			ctx.update_smt_duration(unify_start.elapsed(), timed_out);
			res
		}
	}
}

impl Z3Env<'_> {
	pub fn extract_equiv(&self) -> Bool {
		let Z3Env { ctx, h_ops, aggs, rel_h_ops, .. } = self;
		let (h_ops, aggs, rel_h_ops) = (&*h_ops.borrow(), &*aggs.borrow(), &*rel_h_ops.borrow());
		let expr_eqs = h_ops
			.iter()
			.tuple_combinations()
			.filter_map(|(((op1, args1, rel1, env1), v1), ((op2, args2, rel2, env2), v2))| {
				let dummy: Bool<'_> = Bool::from_bool(ctx.z3_ctx(), true);
				let env = &UnifyEnv(ctx.clone(), env1.clone(), env2.clone(), dummy);
				(op1 == op2 && env.unify(args1, args2) && env.unify(rel1, rel2)).then(|| v1._eq(v2))
			})
			.collect_vec();
		let agg_eqs = aggs
			.iter()
			.tuple_combinations()
			.filter_map(|(((op1, lam1, env1), v1), ((op2, lam2, env2), v2))| {
				let dummy: Bool<'_> = Bool::from_bool(ctx.z3_ctx(), true);
				let env = &UnifyEnv(ctx.clone(), env1.clone(), env2.clone(), dummy);
				(op1 == op2 && env.unify(lam1, lam2)).then(|| v1._eq(v2))
			})
			.collect_vec();
		let rel_eqs = rel_h_ops
			.iter()
			.tuple_combinations()
			.filter_map(
				|(
					((op1, args1, rel1, env1, sq1), (n1, dom1)),
					((op2, args2, rel2, env2, sq2), (n2, dom2)),
				)| {
					let dummy: Bool<'_> = Bool::from_bool(ctx.z3_ctx(), true);
					let env = UnifyEnv(ctx.clone(), env1.clone(), env2.clone(), dummy);
					(op1 == op2
						&& sq1 == sq2 && dom1 == dom2
						&& env.unify(args1, args2)
						&& env.unify(rel1, rel2))
					.then(|| {
						let vars = dom1.iter().map(|ty| ctx.var(ty, "t")).collect_vec();
						let vars = vars.iter().collect_vec();
						let target = if *sq1 { DataType::Boolean } else { DataType::Integer };
						let l = &ctx.app(n1, &vars, &target, false);
						let r = &ctx.app(n2, &vars, &target, false);
						let vars = vars.iter().map(|&v| v as &dyn Ast).collect_vec();
						z3::ast::forall_const(ctx.z3_ctx(), &vars, &[], &l._eq(r))
					})
				},
			)
			.collect_vec();
		Bool::and(
			ctx.z3_ctx(),
			&expr_eqs.iter().chain(agg_eqs.iter()).chain(rel_eqs.iter()).collect_vec(),
		)
	}
}

fn perm_equiv<T: Ord + Clone>(v1: &Vector<T>, v2: &Vector<T>) -> bool {
	v1.len() == v2.len() && {
		let mut v1 = v1.clone();
		let mut v2 = v2.clone();
		v1.sort();
		v2.sort();
		v1 == v2
	}
}

fn perms<T, V>(types: Vec<T>, vars: Vec<V>) -> impl Iterator<Item = Vec<V>>
where
	T: Ord + PartialEq + Clone,
	V: Clone,
{
	use itertools::Either;
	let sort_perm = permutation::sort(types.as_slice());
	let sorted_scope = sort_perm.apply_slice(types.as_slice());
	let sorted_vars = sort_perm.apply_slice(vars.as_slice());
	let groups = sorted_scope.iter().group_by(|a| *a);
	let group_lengths = if types.is_empty() {
		Either::Left(std::iter::once(0))
	} else {
		Either::Right(groups.into_iter().map(|(_, group)| group.count()))
	};
	let mut level = 0;
	let inv_sort_perm = sort_perm.inverse();
	group_lengths
		.map(|length| {
			let perms = (level..level + length).permutations(length);
			level += length;
			perms
		})
		.multi_cartesian_product()
		.map(move |perms| {
			let perm_vec = perms.into_iter().flatten().collect_vec();
			let permute = &inv_sort_perm * &permutation::Permutation::from_vec(perm_vec);
			permute.apply_slice(sorted_vars.as_slice())
		})
}

impl<'c> Unify<Term> for UnifyEnv<'c> {
	fn unify(&self, Sigma(s1, t1): &Term, Sigma(s2, t2): &Term) -> bool {
		if !perm_equiv(s1, s2) {
			return false;
		}
		log::info!("Unifying\n{}\n{}", t1, t2);
		let UnifyEnv(ctx, subst1, subst2, phi) = self;
		let vars1 = s1.iter().map(|ty| ctx.var(ty, "v")).collect();
		let subst1 = subst1 + &vars1;
		perms(s1.iter().cloned().collect(), vars1.into_iter().collect()).take(24).enumerate().any(
			|(i, vars2)| {
				ctx.stats.borrow_mut().nontrivial_perms |= i > 0;
				assert_eq!(vars2.len(), s2.len());
				log::info!("Permutation: {:?}", vars2);
				UnifyEnv(ctx.clone(), subst1.clone(), subst2 + &vars2.into(), phi.clone()).unify(t1, t2)
			},
		)
	}
}

impl Unify<Inner> for UnifyEnv<'_> {
	fn unify(&self, t1: &Inner, t2: &Inner) -> bool {
		let UnifyEnv(ctx, _, _, _) = self;
		let (ref env1, ref env2) = self.envs();
		let z3_ctx = ctx.z3_ctx();
		let (logic1, apps1) = (env1.eval(&t1.logic), env1.eval(&t1.apps));
		let (logic2, apps2) = (env2.eval(&t2.logic), env2.eval(&t2.apps));
		let equiv = logic1
			.ite(&apps1, &Int::from_i64(z3_ctx, 0))
			._eq(&logic2.ite(&apps2, &Int::from_i64(z3_ctx, 0)));
		let solver = &ctx.solver;
		solver.push();
		solver.assert(&Bool::or(z3_ctx, &[&logic1, &logic2]));
		let h_ops_equiv = env1.extract_equiv();
		// let phi = self.phi();
		let antecedent = Bool::and(z3_ctx, &[self.phi(), &h_ops_equiv]);
		solver.pop(1);
		log::info!("{}", equiv);
		log::info!("{}", h_ops_equiv);

		// println!("constraints:\n{}\n", self.phi());
		// println!("antecedent:\n{}\n", antecedent);
		// println!("goal(eq):\n{}\n", equiv);

		let unify_start = Instant::now();
		// let (res, timed_out) = smt(solver, h_ops_equiv.implies(&equiv));
		let (res, timed_out) = smt(solver, antecedent.implies(&equiv));
		ctx.update_smt_duration(unify_start.elapsed(), timed_out);
		res
	}
}

pub(crate) fn smt<'c>(solver: &'c z3::Solver, pred: Bool<'c>) -> (bool, bool) {
	let smt: String = solver
		.dump_smtlib(pred.not())
		.replace(" and", " true")
		.replace(" or", " false")
		.replace(")and", ") true")
		.replace(")or", ") false")
		.replace("(* ", "(* 1 ")
		.replace("(+ ", "(+ 0 ");
	let smt = smt.strip_prefix("; \n(set-info :status )").unwrap_or(smt.as_str());
	let res = crossbeam::atomic::AtomicCell::new(false);
	let last = crossbeam::atomic::AtomicCell::new(false);
	crossbeam::thread::scope(|s| {
		let res = &res;
		let last = &last;
		let p = crossbeam::sync::Parker::new();
		let u1 = p.unparker().clone();
		let u2 = p.unparker().clone();
		let mut z3_cmd = Command::new("z3")
			.args(["-in"])
			.stdin(Stdio::piped())
			.stdout(Stdio::piped())
			.spawn()
			.expect("Failed to spawn child process for z3.");
		let mut z3_in = z3_cmd.stdin.take().expect("Failed to open stdin.");
		let mut z3_out = z3_cmd.stdout.take().expect("Failed to read stdout");
		let mut cvc5_cmd = Command::new("cvc5")
			.args(["--strings-exp"])
			.stdin(Stdio::piped())
			.stdout(Stdio::piped())
			.spawn()
			.expect("Failed to spawn child process for cvc5.");
		let mut cvc5_in = cvc5_cmd.stdin.take().expect("Failed to open stdin.");
		let mut cvc5_out = cvc5_cmd.stdout.take().expect("Failed to capture stdout");
		s.spawn(move |_| {
			z3_in.write_all(smt.as_bytes()).unwrap();
			drop(z3_in);
			let mut result = String::new();
			z3_out.read_to_string(&mut result).expect("Failed to read stdout.");
			log::info!("Z3 result: {}", result);
			let provable = result.starts_with("unsat\n");
			res.fetch_or(provable);
			if result.starts_with("unsat\n") || result.starts_with("sat\n") || last.fetch_or(true) {
				u1.unpark();
			}
		});
		s.spawn(move |_| {
			cvc5_in.write_all("(set-logic ALL)".as_bytes()).unwrap();
			cvc5_in.write_all(smt.as_bytes()).unwrap();
			drop(cvc5_in);
			let mut result = String::new();
			cvc5_out.read_to_string(&mut result).expect("Failed to read stdout.");
			log::info!("CVC5 result: {}", result);
			let provable = result.ends_with("unsat\n");
			res.fetch_or(provable);
			if result.starts_with("unsat\n") || result.starts_with("sat\n") || last.fetch_or(true) {
				u2.unpark();
			}
		});
		let reason = p.park_timeout(Ctx::timeout());
		z3_cmd.kill().unwrap();
		z3_cmd.wait().unwrap();
		cvc5_cmd.kill().unwrap();
		cvc5_cmd.wait().unwrap();
		(res.load(), matches!(reason, UnparkReason::Timeout))
	})
	.unwrap()
}
```

"""pipeline/constraint.rs"""
```rust
use serde::{Deserialize, Serialize};
use crate::pipeline::relation as rel;

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "kind", rename_all = "camelCase")]
pub enum Constraint {
    RelEq { r1: rel::Relation, r2: rel::Relation },
    AttrsEq { a1: rel::Expr, a2: rel::Expr },
    PredEq { p1: rel::Expr, p2: rel::Expr },
    SubAttr { a1: rel::Expr, a2: rel::Expr },
    RefAttr {
        r1: rel::Relation, a1: rel::Expr,
        r2: rel::Relation, a2: rel::Expr
    },
    Unique { r: rel::Relation, a: rel::Expr },
    NotNull { r: rel::Relation, a: rel::Expr },
    FD      { r: rel::Relation, x: Vec<rel::Expr>, y: Vec<rel::Expr> },
    Const   { r: rel::Relation, a: rel::Expr, c: rel::Expr },
    Subset  { r1: rel::Relation, r2: rel::Relation },
}
```
